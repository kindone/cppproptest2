#pragma once

#include "proptest/Shrinkable.hpp"
#include "proptest/Random.hpp"
#include "proptest/Generator.hpp"

/**
 * @file filter.hpp
 * @brief Generator combinator for generating a type with an additional constraint
 */

namespace proptest {

namespace util {
PROPTEST_API GeneratorCommon filterImpl(Function1 gen, Function1 criteria);
} // namespace util

/**
 * @ingroup Combinators
 * @brief You can add a filtering condition to a generator to restrict the generated values to have certain constraint
 * @tparam T generated type
 * @tparam GEN base generator for type T
 * @tparam Criteria a callable with signature T& -> bool
 * @details returns a generator for type T that satisfies criteria predicate (criteria(t) returns true)
 * @code
 * // returns generator for even numbers only out of values generated by intGen
 * filter<int>(intGen, [](int& num) { return num % 2 == 0; });
 * @endcode
 */
template <typename T>
Generator<T> filter(const Generator<T>& gen, Function<bool(T&)> criteria) {
    return util::filterImpl(gen, criteria);
}

/**
 * @ingroup Combinators
 * @brief alias for \ref filter combinator
 */
template <typename T, GenLike GEN, typename Criteria>
decltype(auto) suchThat(GEN&& gen, Criteria&& criteria)
{
    return filter<T>(util::forward<GEN>(gen), util::forward<Criteria>(criteria));
}

}  // namespace proptest
