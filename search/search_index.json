{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"cppproptest","text":"<p><code>cppproptest</code> is a property-based testing library for C++. It focuses on usability with variety of features including:</p> <ul> <li>Out-of-box generators for primitives and standard containers</li> <li>Set of powerful generator combinators for creating new generators from existing generators</li> <li>Shrinking capability for quickly finding root cause of a failure and automated debugging support</li> <li>Stateful testing support for testing state changes</li> <li>Concurrency testing support for testing concurrent state changes</li> </ul> <p>You can get started with <code>cppproptest</code> on this page. For a step-by-step guide to creating your first property test, see the Walkthrough.</p> <p> </p>"},{"location":"#why-property-based-testing","title":"Why Property-based Testing?","text":""},{"location":"#generalization-and-abstraction","title":"Generalization and Abstraction","text":"<p>Property-based testing lets you write tests using general or universal ideas, instead of introducing specific examples or overly contrived scenarios. You can write tests focusing on specifications or requirements of the tested components.</p>"},{"location":"#clear-separation-of-variants-and-invariants","title":"Clear Separation of Variants and Invariants","text":"<p>In reality, we often mix variants and invariants in our tests under typical example-based tests. This is one of the reasons why those tests become hard to maintain and difficult to read over time. Let's see following example-based test for an encoder and a decoder:</p> <pre><code>// a text encoded and then decoded must be identical to original\nMyEncoder encoder;\nMyDecoder decoder;\nauto encodedMsg = encoder.encode(\"Some dummy content that hopefully prove or disprove this works\");\nauto decodedMsg = decoder.decode(encodedMsg);\nASSERT_EQ(\"Some dummy content that hopefully prove or disprove this works\", decodedMsg);\n</code></pre> <p>Even a simple test like this can be confusing, as some dummy string value seems like as if it's conveying significant meaning in the test but in fact it isn't. Turning this dummy value to a free variable would lead to greater generalization of the test:</p> <pre><code>[](std::string originalMsg) {\n    // a text encoded and then decoded must be identical to originalMsg\n    MyEncoder encoder;\n    MyDecoder decoder;\n    auto encodedMsg = encoder.encode(originalMsg);\n    auto decodedMsg = decoder.decode(encodedMsg);\n    PROP_ASSERT_EQ(originalMsg, decodedMsg);\n};\n</code></pre> <p>The new free variable <code>originalMsg</code> becomes the variant part (input domain) of the test while the rest becomes the invariant part.</p> <p>In order to turn this into a concrete test run, we can feed in some random values for the free variable <code>originalMsg</code>. This can be achieved by enclosing this function with <code>forAll()</code> function, which calls the given test function (shown here in the form of lambda) many times with some randomly generated values for the function parameter <code>originalMsg</code>:</p> <pre><code>forAll([](std::string originalMsg) {\n    // a text encoded and then decoded must be identical to original\n    MyEncoder encoder;\n    MyDecoder decoder;\n    auto encodedMsg = encoder.encode(originalMsg);\n    auto decodedMsg = decoder.decode(encodedMsg);\n    PROP_ASSERT_EQ(originalMsg, decodedMsg);\n});\n</code></pre> <p>As a result, <code>forAll()</code> can essentially test the encoder and decoder against arbitrary input strings, by calling the property function hundreds of times (200 is the default number of runs) with some random strings, instead of relying on some dummy values. This let's you validate the property with various forms of a string.</p> <p>With this approach, our test becomes more readable, gets easier to maintain, and expresses the test writer's intention more precisely.</p>"},{"location":"#convenience-and-versatility","title":"Convenience and Versatility","text":"<p>Property-based testing often provides with the convenient out-of-box generators and generator combinators (that can make new generators out of existing ones), and lets you to effortlessly define an input domain tailored for your test. You can specify your input domain using various notions - range, constraint, union, transformation, composition, and dependency, just to name a few.</p> <p>Following example shows how certain input domain of string type can be specified using a built-in generator and generator combinators:</p> <p></p> <pre><code>auto stringGen = gen::integer()\n    .filter([] (int&amp; num) { return num % 2 == 0; }) // even numbers only\n    .map([] (int&amp; num) {\n        return \"&lt;\" + std::to_string(numStr) + \"&gt;\"; // string like \"&lt;0&gt;\", ..., \"&lt;n&gt;\"\n    });\n\nforAll([](std::string original) {\n    // \"&lt;-232&gt;\", &lt;0&gt;, &lt;493284&gt;, ... //\n}, stringGen);\n</code></pre> <p>The <code>forAll</code> function automatically identifies number of parameters and their data types of the given property function. This mechanism allows any number of parameters of simple or complex data types to be used to define a property-based test.</p> <p></p> <p>Once the generators for each parameters are determined, it then automatically feeds in randomly generated values of those types to make a call to the given function as many times as desired. With this powerful generation engine, we can fully parameterize and randomize our tests with high flexibility but with much less effort.</p> <p>With this framework, you don't need to care too much about how to test your requirements. Most of it is automatically done for you by the framework, letting you to focus on what to test, instead.</p> <p> </p>"},{"location":"#further-topics-and-details","title":"Further Topics and Details:","text":"<ul> <li>Getting Started with cppproptest<ul> <li>Step-by-Step Walkthrough</li> </ul> </li> <li>Property API Reference</li> <li>Introduction to generators<ul> <li>Arbitraries, the default generators</li> <li><code>gen</code> namespace - built-in generators and combinators</li> <li>Generating real-world inputs</li> </ul> </li> <li>Generator combinators for creating generators from existing ones</li> <li>Counterexamples and notion of shrinking for automated debugging</li> <li>Printing facilities for custom data types</li> <li>Stateful testing with <code>cppproptest</code></li> <li>Concurrency testing with <code>cppproptest</code></li> <li>Advanced mocking with <code>cppproptest</code> (work in progress)</li> </ul>"},{"location":"AdvancedStatefulTesting/","title":"Advanced Stateful &amp; Concurrency Testing","text":"<p>This page is work in progress</p> <p>Stateful testing opens new possibilities for testing.</p> <ul> <li>Finding memory leaks<ul> <li>With help of a suitable allocation tracker, we can place postcondition check that allocation numbers should come back to 0, after various actions executed and then destructed the object.</li> </ul> </li> <li>Testing with various responses from external dependencies<ul> <li>Complex behavior of mocks can be generated with random sequence of the function specification constructs like ON_CALL of Google Test.</li> </ul> </li> <li>Malfunctions (I/O failures, Network errors, Out-of-memory errors)<ul> <li>With help of a probabilistic malfunction generation functionality we can test for malfunction tolerance of a component, whether it leads to inconsistent states or even crashes</li> <li>A typical malfunction generation functionality may be bound to a resource allocator (OOM) or I/O PIs (network, disk, etc.) that highly depends on external factors</li> <li>A malfunction object may take a floating point argument that decides the probability of malfunctions can happen within the scope<ul> <li>Inside an allocator or I/O API the number set in the malfunction object is read and throws exception if the outcome of the dice is true.</li> </ul> </li> </ul> </li> <li>Thread-safety (concurrency testing)<ul> <li>After various actions are executed in parallel, consistency of the object is validated as postcondition</li> </ul> </li> <li>Testing for Transactional requirements in databases<ul> <li>Transactional visibility as invariant property<ul> <li>Multiple transactions can be maintained and when the same resource (e.g. table) is accessed concurrently, uncommitted changes made should be only visible to current transaction and not in the others.</li> </ul> </li> <li>Atomicity of a transaction<ul> <li>If a sequence of changes is executed, they should be either fully committed or fully rolled back</li> </ul> </li> </ul> </li> </ul>"},{"location":"Arbitrary/","title":"Arbitrary","text":""},{"location":"Arbitrary/#arbitraries-the-default-generators","title":"Arbitraries - The Default Generators","text":""},{"location":"Arbitrary/#what-makes-defaults-so-special","title":"What makes defaults so special","text":"<p>An <code>Arbitrary&lt;T&gt;</code> or its alias <code>Arbi&lt;T&gt;</code> is a generator type (that also coerces to <code>GenFunction&lt;T&gt;</code>). Arbitraries are specially treated in <code>cppproptest</code>. An arbitrary serves as globally defined default generator for the type. If a default generator for a type is available, <code>cppproptest</code> can use the default generator to generate a value of that type, if no generator has been specified.</p> <pre><code>forAll([](T1 t1, T2 t2, ..., TN tn) {\n    // property function body\n}, /* custom generators for T1, ..., TN */);\n</code></pre> <p>For each of the parameter types of a property function, <code>forAll()</code> requires either a custom generator is provided as an argument, or a conforming <code>Arbitrary&lt;T&gt;</code> class has been defined in <code>proptest</code> namespace. A custom generator can be supplied in the <code>forAll()</code> function arguments next to the property function, as in the same order of parameters of the property function. If it hasn't been supplied, <code>forAll()</code> looks up the default generator - the arbitrary - and uses it instead. If there were no <code>proptest::Arbitrary&lt;T&gt;</code> defined, the compilation would fail.</p> <pre><code>// if there is no default generator available, you must provide a generator for the type SomeNewType.\nforAll([](SomeNewType x) {\n}, someNewTypeGen);\n\n\n// explicit generators should be supplied in same order as parameter types of property function\nforAll([](SomeNewType x, SomeOtherType y) {\n}, someNewTypeGen, SomeOtherTypeGen);\n\n\n// if there is a default generator (Arbitrary&lt;SomeType&gt;) available, you can use that generator by omitting the argument\nforAll([](SomeType x) {\n});\n\n// Partially specifying generators is also allowed. Other types will be generated with arbitraries\nforAll([](SomeNewType x, SomeOtherType y) {\n}, someNewTypeGen); // y will be generated with Arbitary&lt;SomeOtherType&gt;\n</code></pre>"},{"location":"Arbitrary/#built-in-arbitraries","title":"Built-in Arbitraries","text":"<p><code>cppproptest</code> provides a set of built-in generators for generation of types that are often used in practice. These built-in generators are in the form of Arbitraries. You can access an arbitrary for <code>T</code> with <code>proptest::Arbitrary&lt;T&gt;</code>. Some of them are defined as template classes with type parameters for universality. For example, <code>protest::Arbitrary&lt;vector&lt;T&gt;&gt;</code> defines a generator for a vector of any given type <code>T</code>, assuming you have an arbitrary for <code>T</code> already defined, or you have provided a custom generator for <code>T</code> as an argument for the vector arbitrary's constructor.</p> <pre><code>auto intVectorGenA = proptest::Arbitrary&lt;std::vector&lt;int&gt;&gt;(); // defaults to proptest::Arbitrary&lt;int&gt;()\nauto intVectorGenB = proptest::Arbitrary&lt;std::vector&lt;int&gt;&gt;(gen::inRange(1,10)); // custom element generator\n\nauto fooVectorGen = proptest::Arbitrary&lt;std::vector&lt;Foo&gt;&gt;(fooGen); // custom generator for T\nauto fooVectorGen = proptest::Arbitrary&lt;std::vector&lt;Foo&gt;&gt;(); // BUILD fails: proptest::Arbitrary&lt;Foo&gt; not available\n</code></pre> <p>Arbitraries of Commonly used standard containers are defined with type parameters so that you can generate such containers for the elemental types you desire.</p> <p>Here's quick reference for built-in arbitraries:</p> Arbitrary Alias Examples <code>Arbi&lt;bool&gt;()</code> <code>gen::boolean()</code> <code>true</code> or <code>false</code> <code>Arbi&lt;char&gt;()</code> <code>gen::character()</code> <code>'c'</code> or <code>'%'</code> <code>Arbi&lt;int&gt;()</code>, <code>Arbi&lt;uint64_t&gt;()</code>, ... <code>gen::int32()</code>, <code>gen::uint64()</code>... <code>12</code> or <code>-1133</code> <code>Arbi&lt;float&gt;()</code>, <code>Arbi&lt;double&gt;()</code> <code>gen::float32()</code>, <code>gen::float64()</code> <code>3.4</code> or <code>-1.4e3</code> <ul> <li>Boolean type:<code>bool</code></li> <li>Character type: <code>char</code></li> <li>Integral types: <code>int8_t</code>, <code>uint8_t</code>, <code>int16_t</code>, <code>uint16_t</code>, <code>int32_t</code>, <code>uint32_t</code>, <code>int64_t</code>, <code>uint64_t</code></li> <li>Floating point types: <code>float</code>, <code>double</code> \u2014 Named parameters: <code>Arbi&lt;float&gt;({.nanProb = 0.1})</code>. See Floating Point Generators.</li> </ul> Arbitrary Alias Examples <code>Arbi&lt;std::string&gt;()</code>, <code>Arbi&lt;UTF8String&gt;()</code> <code>gen::string()</code>, <code>gen::utf8string()</code> <code>\"world\"</code> or <code>\"\u3042\u53f6\u8449\ub9d0\"</code> <code>Arbi&lt;std::pair&lt;T1,T2&gt;&gt;()</code> <code>gen::pair&lt;T1,T2&gt;()</code> <code>{1, \"xv\"}</code> or <code>{true, 3.4}</code> <code>Arbi&lt;std::tuple&lt;Ts...&gt;&gt;()</code> <code>gen::tuple&lt;Ts...&gt;()</code> <code>{1, \"xv\", true}</code> or <code>{true, 3.4}</code> <code>Arbi&lt;std::list&lt;T&gt;&gt;()</code> <code>gen::list&lt;T&gt;()</code> <code>{10, -4, 0}</code> or <code>{\"k\", \"&amp;\"}</code> <code>Arbi&lt;std::vector&lt;T&gt;&gt;()</code> <code>gen::vector&lt;T&gt;()</code> <code>{10, -4, 0}</code> or <code>{\"k\", \"&amp;\"}</code> <code>Arbi&lt;std::set&lt;T&gt;&gt;()</code> <code>gen::set&lt;T&gt;()</code> set <code>{1, 3, 4}</code> but not <code>{1, 1, 3}</code> <code>Arbi&lt;std::map&lt;K,V&gt;&gt;()</code> <code>gen::map&lt;K,V&gt;()</code> map of <code>\"Bob\" -&gt; 25, \"Alice\" -&gt; 30</code> <ul> <li>String types:<ul> <li><code>std::string</code> (defaults to generate ASCII character strings in [0x01, 0x7F] range)</li> <li><code>UTF8String</code> (a class which extends <code>std::string</code> and can be used to generate valid UTF-8 strings by using <code>Arbi&lt;UTF8String&gt;</code>)</li> <li><code>CESU8String</code> (similar to UTF-8, but can be used to generate valid CESU-8 strings)</li> <li><code>UTF16BEString</code> and <code>UTF16LEString</code> for UTF-16 big and little endian strings. CESU-8 and Unicode types produce full unicode code point range of [0x1, 0x10FFFF], excluding forbidden surrogate code points ([0xD800, 0xDFFF])</li> </ul> </li> <li>Shared pointers: <code>std::shared_ptr&lt;T&gt;</code> where an <code>Arbi&lt;T&gt;</code> or a custom generator for <code>T</code> is available. It's also useful for generating polymorphic types.     <pre><code>struct Action {\n    virtual int get() = 0;\n};\nstruct Insert : Action {\n    virtual void get() { return 1; }\n};\nstruct Delete : Action {\n    virtual void get() { return 2; }\n};\nGenerator&lt;std::shared_ptr&lt;Action&gt;&gt;(...); // can hold both Insert and Delete\n</code></pre></li> <li> <p>Standard containers: <code>std::string</code>, <code>std::vector</code>, <code>std::list</code>, <code>std::set</code>, <code>std::pair</code>, <code>std::tuple</code>, <code>std::map</code></p> <ul> <li> <p>Arbitraries for containers can optionally take a custom generator for their elemental types. If no custom generator for elemental type <code>T</code> is provided, <code>Arbitrary&lt;T&gt;</code> will be used instead.     <pre><code>// You can supply a specific generator for integers\nauto vecInt0to100 = Arbi&lt;std::vector&lt;int&gt;&gt;(gen::interval&lt;int&gt;(0,100));\n// otherwise, Arbi&lt;int&gt; is used\nauto vecInt = Arbi&lt;std::vector&lt;int&gt;&gt;();\n\n// Named parameters (util::ContainerGenConfig&lt;T&gt;)\nauto vecGen = Arbi&lt;std::vector&lt;int&gt;&gt;({.minSize = 5, .maxSize = 20});\nauto vecGen2 = Arbi&lt;std::vector&lt;int&gt;&gt;({.elemGen = gen::interval&lt;int&gt;(1, 100), .minSize = 5, .maxSize = 20});\n\n// String arbitraries: ContainerGenConfig&lt;char&gt; for std::string, ContainerGenConfig&lt;uint32_t&gt; for UTF-8/16/CESU-8\nauto strGen = Arbi&lt;std::string&gt;({.minSize = 5, .maxSize = 20});\nauto utf8Gen = Arbi&lt;UTF8String&gt;({.elemGen = gen::interval&lt;uint32_t&gt;('0', '9'), .minSize = 1, .maxSize = 10});\n\n// string aarbitraries also take optional element generator\nauto uppercaseGen = Arbi&lt;std::string&gt;(gen::interval('A', 'Z'));\nauto alphabetGen = Arbi&lt;std::string&gt;(gen::unionOf(gen::interval('A', 'Z'), gen::interval('a','z')));\n</code></pre></p> </li> <li> <p><code>Arbi&lt;std::map&lt;K,V&gt;&gt;</code> provides a pair generator and size constraints. Use <code>setPairGen</code> or the config constructor.</p> <pre><code>auto mapGen = Arbi&lt;std::map&lt;int,int&gt;&gt;();\nmapGen.setPairGen(gen::pair(gen::interval&lt;int&gt;(0,100), gen::interval&lt;int&gt;(-100, 100)));\n\n// Named parameters (util::MapGenConfig&lt;K,V&gt;)\nauto mapGen2 = Arbi&lt;std::map&lt;int,int&gt;&gt;({.minSize = 5, .maxSize = 20});\nauto mapGen3 = Arbi&lt;std::map&lt;int,int&gt;&gt;({.keyGen = gen::int32(), .valueGen = gen::int32(), .minSize = 5, .maxSize = 20});\n</code></pre> </li> <li> <p>Containers provide methods for configuring the desired sizes</p> <ul> <li><code>setMinSize(size)</code>, <code>setMaxSize(size)</code> for restricting the container to specific range of sizes</li> <li><code>setSize(size)</code> for restricting the container to a specific size</li> </ul> <pre><code>auto vecInt = Arbi&lt;std::vector&lt;int&gt;&gt;();\nvecInt.setSize(10);    // 1) generated vector will always have size 10\nvecInt.setMinSize(1);  // 2) generated vector will have size &gt;= 1\nvecInt.setMaxSize(10); //    generated vector will have size &lt;= 10\nvecInt.setSize(1, 10); // 3) generated vector will have size &gt;= 1 and size &lt;= 10\n</code></pre> </li> </ul> </li> </ul> <p>As long as a generator for type <code>T</code> is available (either by <code>Arbitary&lt;T&gt;</code> defined or a custom generator provided), you can generate a container of that type, however complex the type <code>T</code> is, even including another container type. This means you can readily generate a random <code>vector&lt;vector&lt;int&gt;&gt;</code>, as <code>Arbitrary&lt;vector&lt;T&gt;&gt;</code> and <code>Arbitrary&lt;int&gt;</code> are both available.</p> <pre><code>    Arbi&lt;std::vector&lt;std::vector&lt;int&gt;&gt;&gt;(); // generates a vector of vector of ints.\n    Arbi&lt;std::map&lt;std::string, std::vector&lt;std::set&lt;int&gt;&gt;&gt;&gt;();\n</code></pre> <p>This design makes arbitraries of <code>cppproptest</code> composable, meaning that they can be easily reusable as building blocks for a new generator.</p>"},{"location":"Arbitrary/#defining-an-arbitrary","title":"Defining an Arbitrary","text":"<p>With template specialization, new <code>proptest::Arbi&lt;T&gt;</code> (or its alias <code>proptest::Arbitrary&lt;T&gt;</code>) for type <code>T</code> can be defined, if it hasn't been already defined yet. By defining an Arbitrary, you are effectively adding a default generator for a type.</p> <p>Following shows an example of defining an Arbitrary. Note that it should be defined under <code>proptest</code> namespace in order to be recognized and accessible by the library.</p> <pre><code>namespace proptest { // you should define your Arbi&lt;T&gt; inside this namespace\n\n// define a template specialization of Arbi for Car type\n// by extending ArbiBase, you are decorating your arbitrary with standard methods (map, flatMap, filter, etc.)\ntemplate &lt;&gt;\nstruct Arbi&lt;Car&gt; : ArbiBase&lt;Car&gt; {\n  Shrinkable&lt;Car&gt; operator()(Random&amp; rand) const {\n    bool isAutomatic = rand.getRandomBool();\n    return make_shrinkable&lt;Car&gt;(isAutomatic); // make_shrinkable creates a Car object by calling Car's constructor with 1 boolean parameter\n  }\n};\n\n}\n</code></pre> <p>Although you can define an arbitrary as shown in this example, it's only required to do so if you desire to have a default generator for the type.</p>"},{"location":"Arbitrary/#utility-methods-of-arbitrary","title":"Utility methods of Arbitrary","text":"<p><code>Arbitrary&lt;T&gt;</code> provides useful helpers for creating new generators from existing ones[^generatorT]. <code>filter</code> is such a helper. It restrictively generates values that satisfy a criteria function. Following shows an even number generator from the integer <code>Arbitrary</code>.</p> <pre><code>// generates any integers\nauto anyIntGen = Arbi&lt;int&gt;();\n// generates even integers\nauto evenGen = anyIntGen.filter([](int num) {\n    return num % 2 == 0;\n});\n</code></pre> <p>You can find the full list of such helpers in Utility methods in standard generators.</p> <p> </p>"},{"location":"Combinators/","title":"Generator Combinators","text":"<p>New to property-based testing? Start with the Walkthrough for a step-by-step guide. This page provides a comprehensive reference for all generator combinators in <code>cppproptest</code>.</p> <p>Generator combinators are functions that build new generators from existing ones. Many combinators are inspired by functional programming patterns and can be chained together to create complex generation logic.</p> <p>Generator objects provide <code>.filter()</code>, <code>.map()</code>, <code>.flatMap()</code>, <code>.pairWith()</code>, and <code>.tupleWith()</code> as member methods. They are equivalent to standalone <code>gen::*</code> higher order combinator functions (<code>gen::filter()</code>, <code>gen::transform()</code>, <code>gen::derive()</code>, <code>gen::dependency()</code>, and <code>gen::chain()</code>) under the hood.</p> <p> </p>"},{"location":"Combinators/#utility-methods-quick-reference","title":"Utility Methods Quick Reference","text":"<p>Call these on any generator object (e.g., <code>gen::int32()</code>, <code>gen::string()</code>, <code>Arbi&lt;MyType&gt;()</code>).</p> Method Purpose Example <code>.filter(predicate)</code> Keep only values satisfying a condition <code>gen::int32().filter([](int n) { return n % 2 == 0; })</code> <code>.map&lt;U&gt;(mapper)</code> Transform each value to another type <code>gen::int32().map&lt;std::string&gt;([](int n) { return std::to_string(n); })</code> <code>.flatMap&lt;U&gt;(genUFromT)</code> Derive a new generator based on each value <code>gen::interval(1,10).flatMap&lt;std::string&gt;([](int n) { auto g = gen::string(); g.setSize(n); return g; })</code> <code>.pairWith&lt;U&gt;(genUFromT)</code> Generate a pair where second element depends on first <code>gen::interval(1,100).pairWith&lt;std::vector&lt;int&gt;&gt;([](int n) { auto g = gen::vector&lt;int&gt;(); g.setSize(n); return g; })</code> <code>.tupleWith&lt;U&gt;(genUFromT)</code> Chain dependent generators into a tuple <code>gen::boolean().tupleWith&lt;int&gt;([](bool b) { return b ? gen::interval(0,50) : gen::interval(51,100); })</code> <code>.noShrink()</code> Same values, but with empty shrink stream (for seeds, UUIDs, timestamps) <code>gen::uint64().noShrink()</code> <p> </p>"},{"location":"Combinators/#utility-methods-in-standard-generators","title":"Utility Methods in Standard Generators","text":"<p>Standard generator objects (returned by <code>gen::*</code>, <code>Arbi&lt;T&gt;</code>, <code>gen::construct&lt;T&gt;</code>, etc.) provide member methods that mirror the standalone combinators. These methods allow fluent chaining and are readily discoverable via autocomplete.</p> <p>Underlying type: <code>Generator&lt;T&gt;</code>, representing a function <code>(Random&amp;) -&gt; Shrinkable&lt;T&gt;</code> (aliased as <code>GenFunction&lt;T&gt;</code>).</p> <p> </p>"},{"location":"Combinators/#filterfilterer","title":"<code>.filter(filterer)</code>","text":"<p>Applies a predicate to keep only values that satisfy the condition. Equivalent to <code>gen::filter&lt;T&gt;(*this, filterer)</code>.</p> <p>Signature: <code>Generator&lt;T&gt;::filter(filterer) -&gt; Generator&lt;T&gt;</code> where <code>filterer</code> is <code>function&lt;bool(const T&amp;)&gt;</code></p> <p>Example:</p> <pre><code>// Generate even numbers\nauto evenGen = gen::int32().filter([](const int&amp; num) {\n    return num % 2 == 0;\n});\n\n// Generate positive integers\nauto positiveGen = gen::int32().filter([](const int&amp; num) {\n    return num &gt; 0;\n});\n\n// Chain with other methods\nauto evenPositiveGen = gen::int32()\n    .filter([](const int&amp; n) { return n &gt; 0; })\n    .filter([](const int&amp; n) { return n % 2 == 0; });\n</code></pre> <p>See also: gen::filter (standalone form), Applying Constraints</p> <p> </p>"},{"location":"Combinators/#mapumapper","title":"<code>.map&lt;U&gt;(mapper)</code>","text":"<p>Transforms each generated value to type <code>U</code>. Equivalent to <code>gen::transform&lt;T,U&gt;(*this, mapper)</code>.</p> <p>Signature: <code>Generator&lt;T&gt;::map&lt;U&gt;(mapper) -&gt; Generator&lt;U&gt;</code> where <code>mapper</code> is <code>function&lt;U(const T&amp;)&gt;</code></p> <p>Example:</p> <pre><code>// Generate strings from integers\nauto numStringGen = gen::int32().map&lt;std::string&gt;([](const int&amp; num) {\n    return std::to_string(num);\n});\n\n// Generate uppercase strings from lowercase\nauto upperGen = gen::string().map&lt;std::string&gt;([](const std::string&amp; str) {\n    std::string upper = str;\n    std::transform(upper.begin(), upper.end(), upper.begin(), ::toupper);\n    return upper;\n});\n\n// Chain: int -&gt; string -&gt; string length\nauto lengthGen = gen::int32()\n    .map&lt;std::string&gt;([](const int&amp; n) { return std::to_string(n); })\n    .map&lt;size_t&gt;([](const std::string&amp; s) { return s.size(); });\n</code></pre> <p>See also: gen::transform (standalone form), Transforming or Mapping</p> <p> </p>"},{"location":"Combinators/#flatmapugenufromt","title":"<code>.flatMap&lt;U&gt;(genUFromT)</code>","text":"<p>Based on each generated value of type <code>T</code>, obtains a new generator for type <code>U</code> and uses it to produce the final value. Equivalent to <code>gen::derive&lt;T,U&gt;(*this, genUFromT)</code>.</p> <p>Signature: <code>Generator&lt;T&gt;::flatMap&lt;U&gt;(genUFromT) -&gt; Generator&lt;U&gt;</code> where <code>genUFromT</code> is <code>function&lt;Generator&lt;U&gt;(const T&amp;)&gt;</code></p> <p>Example:</p> <pre><code>// Generate a string whose max size depends on a generated integer\nauto stringGen = gen::interval(1, 50).flatMap&lt;std::string&gt;([](const int&amp; maxSize) {\n    auto sizedStringGen = gen::string();\n    sizedStringGen.setMaxSize(maxSize);\n    return sizedStringGen;\n});\n\n// Generate different character sets based on a selector\nauto charGen = gen::interval(0, 2).flatMap&lt;char&gt;([](const int&amp; n) {\n    if (n == 0) return gen::interval('A', 'Z');\n    if (n == 1) return gen::interval('a', 'z');\n    return gen::interval('0', '9');\n});\n</code></pre> <p>See also: gen::derive (standalone form), Deriving or Flat-mapping</p> <p> </p>"},{"location":"Combinators/#pairwithugenufromt-and-tuplewithugenufromt","title":"<code>.pairWith&lt;U&gt;(genUFromT)</code> and <code>.tupleWith&lt;U&gt;(genUFromT)</code>","text":"<p>Chain the current generator with another where the second depends on the first. <code>.pairWith&lt;U&gt;</code> produces <code>std::pair&lt;T,U&gt;</code>. <code>.tupleWith&lt;U&gt;</code> produces <code>std::tuple&lt;T,U&gt;</code> and can be chained further.</p> <p>Example:</p> <pre><code>// Size and vector of that size\nauto sizeAndVectorGen = gen::interval(1, 100).pairWith&lt;std::vector&lt;bool&gt;&gt;(\n    [](const int&amp; size) {\n        auto g = gen::vector&lt;bool&gt;();\n        g.setSize(size);\n        return g;\n    }\n);\n\n// Chain multiple dependent generators\nauto complexGen = gen::boolean()\n    .tupleWith&lt;int&gt;([](const bool&amp; isEven) -&gt; Generator&lt;int&gt; {\n        return isEven\n            ? gen::int32().filter([](int v) { return v % 2 == 0; })\n            : gen::int32().filter([](int v) { return v % 2 != 0; });\n    })\n    .tupleWith&lt;std::string&gt;([](const std::tuple&lt;bool, int&gt;&amp; pair) -&gt; Generator&lt;std::string&gt; {\n        int size = std::max(0, std::abs(std::get&lt;1&gt;(pair)) % 100);\n        auto g = gen::string();\n        g.setSize(size);\n        return g;\n    });\n// Result: Generator&lt;std::tuple&lt;bool, int, std::string&gt;&gt;\n</code></pre> <p>See also: gen::dependency, gen::chain, Values with Dependencies</p> <p> </p>"},{"location":"Combinators/#noshrink","title":"<code>.noShrink()</code>","text":"<p>Returns a generator that produces the same values but with an empty shrink stream. Use when shrinking (simplification of a counterexample) is meaningless (e.g., seeds, UUIDs, timestamps).</p> <p>Signature: <code>Generator&lt;T&gt;::noShrink() -&gt; Generator&lt;T&gt;</code></p> <p>Example:</p> <pre><code>// Seed that should not be shrunk during failure minimization\nauto seedGen = gen::uint64().noShrink();\n\n// Equivalent free function form\nauto seedGen = gen::noShrink(gen::uint64());\n</code></pre> <p>See also: gen::noShrink (standalone form)</p> <p> </p>"},{"location":"Combinators/#standalone-combinators-quick-reference","title":"Standalone Combinators Quick Reference","text":"<p>The <code>gen::*</code> functions are the underlying implementations for the utility methods above. Some combinators (e.g., <code>gen::just</code>, <code>gen::elementOf</code>) have no method form and are used directly.</p> Combinator Purpose Underlying / Alias for <code>gen::just&lt;T&gt;</code> Generate a constant value \u2014 <code>gen::lazy&lt;T&gt;</code> Generate by calling a function \u2014 <code>gen::elementOf&lt;T&gt;</code> Select from constant values \u2014 <code>gen::interval&lt;T&gt;</code>, <code>gen::natural&lt;T&gt;</code>, etc. Numeric ranges Generators.md <code>gen::pair</code>, <code>gen::tuple</code> Combine generators \u2014 <code>gen::oneOf&lt;T&gt;</code> Select from multiple generators \u2014 <code>gen::construct&lt;T,Args...&gt;</code> Generate via constructor \u2014 <code>gen::filter&lt;T&gt;</code> Filter by predicate <code>.filter()</code> <code>gen::noShrink</code> Same values, but with empty shrink stream <code>.noShrink()</code> <code>gen::transform&lt;T,U&gt;</code> Transform to another type <code>.map&lt;U&gt;()</code> <code>gen::derive&lt;T,U&gt;</code> Derive generator from value <code>.flatMap&lt;U&gt;()</code> <code>gen::dependency&lt;T,U&gt;</code> Pair with dependent second <code>.pairWith&lt;U&gt;()</code> <code>gen::chain&lt;Ts...,U&gt;</code> Tuple with dependent element <code>.tupleWith&lt;U&gt;()</code> <code>gen::aggregate&lt;T&gt;</code>, <code>gen::accumulate&lt;T&gt;</code> Sequential dependent generation \u2014 <p> </p>"},{"location":"Combinators/#basic-generator-combinators","title":"Basic Generator Combinators","text":""},{"location":"Combinators/#constants","title":"Constants","text":""},{"location":"Combinators/#genjustt","title":"<code>gen::just&lt;T&gt;</code>","text":"<p>Generates a constant value. Useful when you need a fixed value in your property tests.</p> <p>Signatures:</p> <ul> <li><code>gen::just&lt;T&gt;(T*)</code> - Takes a pointer to a value</li> <li><code>gen::just&lt;T&gt;(T)</code> - Takes a value by copy</li> <li><code>gen::just&lt;T&gt;(shared_ptr&lt;T&gt;)</code> - Takes a shared pointer (useful for non-copyable types)</li> </ul> <p>Example:</p> <pre><code>auto zeroGen = gen::just(0); // template argument is optional if type is deducible\nauto stringGen = gen::just&lt;std::string&gt;(\"hello\");\n</code></pre> <p>See also: Generators.md</p>"},{"location":"Combinators/#genlazyt","title":"<code>gen::lazy&lt;T&gt;</code>","text":"<p>Generates a value by calling a function each time. Useful when you need to generate a fresh value on each call (e.g., for mutable objects or time-dependent values).</p> <p>Signature: <code>gen::lazy&lt;T&gt;(function&lt;T()&gt;)</code></p> <p>Example:</p> <pre><code>auto oneGen = gen::lazy&lt;int&gt;([]() { return 1; });\nauto timestampGen = gen::lazy&lt;int64_t&gt;([]() { return getCurrentTimestamp(); });\n</code></pre> <p>See also: Generators.md</p>"},{"location":"Combinators/#selecting-from-constants","title":"Selecting from Constants","text":""},{"location":"Combinators/#genelementoft","title":"<code>gen::elementOf&lt;T&gt;</code>","text":"<p>Randomly selects one value from a provided list of constant values. Useful for choosing from a fixed set of options.</p> <p>Signature: <code>gen::elementOf&lt;T&gt;(val1, ..., valN)</code></p> <p>Example:</p> <pre><code>// generates a prime number under 50\nauto primeGen = gen::elementOf&lt;int&gt;(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47);\n\n// generates a HTTP method\nauto httpMethodGen = gen::elementOf&lt;std::string&gt;(\"GET\", \"POST\", \"PUT\", \"DELETE\");\n</code></pre> <p>Weighted Selection:</p> <p><code>gen::elementOf</code> supports probabilistic weights (<code>0 &lt; weight &lt;= 1</code>). The sum of weights should ideally be 1.0 but must not exceed 1.0. If a weight is unspecified for a value, the remaining probability (1.0 minus the sum of specified weights) is distributed evenly among the values without specified weights.</p> <p>Use <code>gen::weightedVal(&lt;value&gt;, &lt;weight&gt;)</code> to annotate the desired weight.</p> <p>Example:</p> <pre><code>// generates 2, 5, or 10 with specified probabilities\n// weight for 10 automatically becomes 1.0 - 0.8 - 0.15 == 0.05\ngen::elementOf&lt;int&gt;(gen::weightedVal(2, 0.8), gen::weightedVal(5, 0.15), 10);\n</code></pre> <p>See also: Generators.md</p>"},{"location":"Combinators/#integers-and-intervals","title":"Integers and Intervals","text":"<p>Utility generators for generating integers within specific ranges. These combinators are convenient wrappers around the base integer generators.</p> <p>See also: Generators.md for more details on numeric range generators.</p>"},{"location":"Combinators/#genintervalt","title":"<code>gen::interval&lt;T&gt;</code>","text":"<p>Generates an integer type in the closed interval <code>[min, max]</code> (both endpoints inclusive).</p> <p>Signature: <code>gen::interval&lt;INT_TYPE&gt;(min, max)</code></p> <p>Example:</p> <pre><code>gen::interval&lt;int64_t&gt;(1, 28);\ngen::interval(1, 48); // template type argument can be omitted if input type matches output type\ngen::interval(0, 10); // generates an integer in {0, ..., 10}\ngen::interval('A', 'Z'); // generates a char of uppercase alphabet\n</code></pre>"},{"location":"Combinators/#genintegerst","title":"<code>gen::integers&lt;T&gt;</code>","text":"<p>Generates an integer type starting from <code>from</code> with a count of values.</p> <p>Signature: <code>gen::integers&lt;INT_TYPE&gt;(from, count)</code></p> <p>Example:</p> <pre><code>gen::integers(0, 10); // generates an integer in {0, ..., 9}\ngen::integers(1, 10); // generates an integer in {1, ..., 10}\n</code></pre>"},{"location":"Combinators/#gennaturalt","title":"<code>gen::natural&lt;T&gt;</code>","text":"<p>Generates a positive integer (greater than 0) up to <code>max</code> (inclusive).</p> <p>Signature: <code>gen::natural&lt;INT_TYPE&gt;(max)</code></p> <p>Example:</p> <pre><code>auto positiveGen = gen::natural&lt;int&gt;(100); // generates integers in {1, ..., 100}\n</code></pre>"},{"location":"Combinators/#gennonnegativet","title":"<code>gen::nonNegative&lt;T&gt;</code>","text":"<p>Generates zero or a positive integer (&gt;= 0) up to <code>max</code> (inclusive).</p> <p>Signature: <code>gen::nonNegative&lt;INT_TYPE&gt;(max)</code></p> <p>Example:</p> <pre><code>auto nonNegGen = gen::nonNegative&lt;int&gt;(100); // generates integers in {0, ..., 100}\n</code></pre> <p>Note: <code>gen::interval</code>, <code>gen::inRange</code>, and <code>gen::integers</code> are essentially the same with subtle differences for user preference. See Generators.md for details.</p>"},{"location":"Combinators/#pair-and-tuples","title":"Pair and Tuples","text":"<p>Combine generators of different types to produce <code>std::pair</code> or <code>std::tuple</code> values. These are convenient wrappers that support type inference.</p> <p>See also: Generators.md for more details on tuple and pair generators.</p>"},{"location":"Combinators/#genpairt1t2","title":"<code>gen::pair&lt;T1,T2&gt;</code>","text":"<p>Generates a <code>std::pair&lt;T1,T2&gt;</code> based on the results of two generators.</p> <p>Signature: <code>gen::pair(gen1, gen2)</code></p> <p>Example:</p> <pre><code>auto pairGen = gen::pair(gen::int32(), gen::string());\n// Equivalent to: gen::pair&lt;int32_t, std::string&gt;(gen::int32(), gen::string())\n</code></pre>"},{"location":"Combinators/#gentuplets","title":"<code>gen::tuple&lt;Ts...&gt;</code>","text":"<p>Generates a <code>std::tuple&lt;T1,...,TN&gt;</code> based on the results of multiple generators.</p> <p>Signature: <code>gen::tuple(gen1, ..., genN)</code></p> <p>Example:</p> <pre><code>auto tupleGen = gen::tuple(gen::int32(), gen::string(), gen::float64());\n// Generates std::tuple&lt;int32_t, std::string, double&gt;\n</code></pre> <p> </p> <p> </p>"},{"location":"Combinators/#advanced-generator-combinators","title":"Advanced Generator Combinators","text":""},{"location":"Combinators/#selecting-from-generators","title":"Selecting from Generators","text":"<p>Combine multiple generators of the same type into a single generator that randomly selects one of the underlying generators to produce a value. This can be considered as taking a union of generators.</p>"},{"location":"Combinators/#genoneoft","title":"<code>gen::oneOf&lt;T&gt;</code>","text":"<p>Generates a value of type <code>T</code> by randomly choosing one of the provided generators or values. Each argument can be: - a generator (GenLike) - <code>weightedGen(generator, weight)</code> - a raw value of type <code>T</code> (treated as <code>gen::just(value)</code>)</p> <p>Signature: <code>gen::oneOf&lt;T&gt;(gen1, ..., genN)</code> or <code>gen::oneOf&lt;T&gt;(val1, val2, ...)</code> or mixed</p> <p>Example:</p> <pre><code>// generates a numeric within ranges [0,10], [100, 1000], [10000, 100000]\nauto rangeGen = gen::oneOf&lt;int&gt;(\n    gen::interval(0, 10),\n    gen::interval(100, 1000),\n    gen::interval(10000, 100000)\n);\n\n// Raw values (implicit gen::just) can be used\nauto fixedGen = gen::oneOf&lt;int&gt;(1339, 42); // equivalent to gen::oneOf&lt;int&gt;(gen::just(1339), gen::just(42))\n\n// Mixed: raw values and generators\nauto mixedGen = gen::oneOf&lt;int&gt;(1339, gen::interval(0, 10), 42);\n</code></pre> <p>Weighted Selection:</p> <p><code>gen::oneOf</code> supports probabilistic weights (<code>0 &lt; weight &lt;= 1</code>). The sum of weights should ideally be 1.0 but must not exceed 1.0. If a weight is unspecified for a generator, the remaining probability (1.0 minus the sum of specified weights) is distributed evenly among the generators without specified weights.</p> <p>Use <code>weightedGen(&lt;generator&gt;, &lt;weight&gt;)</code> to annotate the desired weight.</p> <p>Example:</p> <pre><code>// generates a numeric within ranges with specified probabilities\n// weight for third generator automatically becomes 1.0 - (0.8 + 0.15) == 0.05\nauto weightedRangeGen = gen::oneOf&lt;int&gt;(\n    weightedGen(gen::interval(0, 10), 0.8),\n    weightedGen(gen::interval(100, 1000), 0.15),\n    gen::interval(10000, 100000)\n);\n</code></pre>"},{"location":"Combinators/#genunionoft","title":"<code>gen::unionOf&lt;T&gt;</code>","text":"<p>Alias of <code>gen::oneOf&lt;T&gt;</code>.</p> <p>See also: Generators.md</p>"},{"location":"Combinators/#constructing-an-object","title":"Constructing an Object","text":"<p>Generate objects of a class or struct type <code>T</code> by calling a matching constructor.</p>"},{"location":"Combinators/#genconstructt-args","title":"<code>gen::construct&lt;T, Args...&gt;</code>","text":"<p>Generates an object of type <code>T</code> by calling its constructor that matches the signature <code>(ARG1, ..., ARGN)</code>. Custom generators can be supplied for generating arguments. If fewer generators are provided than constructor arguments, the remaining arguments are generated using their default <code>Arbi</code> generators.</p> <p>Signature: <code>gen::construct&lt;T, ARG1, ..., ARGN&gt;([gen1, ..., genM])</code></p> <p>Example:</p> <pre><code>struct Coordinate {\n    Coordinate(int x, int y) {\n        // ...\n    }\n};\n\n// Generate Coordinate with custom generators for both arguments\nauto coordinateGen1 = gen::construct&lt;Coordinate, int, int&gt;(\n    gen::interval(-10, 10),\n    gen::interval(-20, 20)\n);\n\n// Generate Coordinate with custom generator for x only; y uses default Arbi&lt;int&gt;\nauto coordinateGen2 = gen::construct&lt;Coordinate, int, int&gt;(\n    gen::interval(-10, 10)\n);\n</code></pre> <p>See also: Arbitrary.md for information on default generators</p>"},{"location":"Combinators/#applying-constraints","title":"Applying Constraints","text":"<p>Add a filtering condition to a generator to restrict generated values to satisfy a certain constraint.</p>"},{"location":"Combinators/#genfiltert","title":"<code>gen::filter&lt;T&gt;</code>","text":"<p>Underlying implementation of <code>.filter()</code>.</p> <p>Generates a value of type <code>T</code> using the base generator <code>gen</code>, but only yields values that satisfy the <code>condition_predicate</code> (i.e., for which the predicate returns <code>true</code>). If the predicate returns <code>false</code>, the generation is retried with a new value from <code>gen</code>.</p> <p>Signature: <code>gen::filter&lt;T&gt;(gen, condition_predicate)</code></p> <p>Example:</p> <pre><code>// generates even numbers\nauto evenGen = gen::filter&lt;int&gt;(gen::int32(), [](const int&amp; num) {\n    return num % 2 == 0;\n});\n\n// generates positive integers\nauto positiveGen = gen::filter&lt;int&gt;(gen::int32(), [](const int&amp; num) {\n    return num &gt; 0;\n});\n</code></pre> <p>Note: Using <code>gen::filter</code> with tight constraints can be inefficient, as many values may be discarded. Consider using dependency combinators or custom generators for better performance.</p>"},{"location":"Combinators/#gensuchthatt","title":"<code>gen::suchThat&lt;T&gt;</code>","text":"<p>Alias of <code>gen::filter&lt;T&gt;</code>.</p>"},{"location":"Combinators/#gennoshrink","title":"<code>gen::noShrink</code>","text":"<p>Wraps a generator to produce the same values but with an empty shrink stream. Use when shrinking is meaningless (e.g., seeds, UUIDs, timestamps). Equivalent to <code>.noShrink()</code>.</p> <p>Signature: <code>gen::noShrink(gen) -&gt; Generator&lt;T&gt;</code></p> <p>Example:</p> <pre><code>// Seed that should not be shrunk during failure minimization\nauto seedGen = gen::noShrink(gen::uint64());\n// Equivalent to: gen::uint64().noShrink()\n</code></pre> <p>See also: CustomGenerator.md for creating generators with built-in constraints</p>"},{"location":"Combinators/#transforming-or-mapping","title":"Transforming or Mapping","text":"<p>Transform an existing generator to create a new generator by providing a transformer function. This is equivalent to mapping in functional programming.</p>"},{"location":"Combinators/#gentransformtu","title":"<code>gen::transform&lt;T,U&gt;</code>","text":"<p>Underlying implementation of <code>.map&lt;U&gt;()</code>.</p> <p>Generates type <code>U</code> based on a generator for type <code>T</code>, using a transformer function that converts a value of type <code>const T&amp;</code> to type <code>U</code>.</p> <p>Signature: <code>gen::transform&lt;T,U&gt;(gen, transformer)</code></p> <p>Example:</p> <pre><code>// generates strings from integers (e.g. \"0\", \"1\", ... , \"-16384\")\nauto numStringGen = gen::transform&lt;int, std::string&gt;(\n    gen::int32(),\n    [](const int&amp; num) {\n        return std::to_string(num);\n    }\n);\n\n// generates uppercase strings from lowercase strings\nauto upperGen = gen::transform&lt;std::string, std::string&gt;(\n    gen::string(),\n    [](const std::string&amp; str) {\n        std::string upper = str;\n        std::transform(upper.begin(), upper.end(), upper.begin(), ::toupper);\n        return upper;\n    }\n);\n</code></pre> <p>See also: Deriving or Flat-mapping for context-dependent generation, Utility Methods for fluent chaining with <code>.map&lt;U&gt;()</code></p>"},{"location":"Combinators/#deriving-or-flat-mapping","title":"Deriving or Flat-mapping","text":"<p>Another combinator that resembles <code>gen::transform</code> is <code>gen::derive</code>. This is equivalent to flat-mapping or binding in functional programming. The key difference from <code>gen::transform&lt;T, U&gt;</code> is that the function provided to <code>gen::derive</code> returns a new generator (<code>Generator&lt;U&gt;</code>) based on the intermediate value of type <code>T</code>, rather than just transforming the value into a <code>U</code>. This allows for more complex, context-dependent generation logic.</p>"},{"location":"Combinators/#genderivetu","title":"<code>gen::derive&lt;T,U&gt;</code>","text":"<p>Underlying implementation of <code>.flatMap&lt;U&gt;()</code>.</p> <p>Derives a new generator for type <code>U</code>. It first generates a value of type <code>T</code> using <code>genT</code>. Then, it passes this value to <code>genUGen</code>, which is a function that returns a <code>Generator&lt;U&gt;</code>. This returned generator is then used to produce the final value of type <code>U</code>.</p> <p>Signature: <code>gen::derive&lt;T, U&gt;(genT, genUGen)</code></p> <p>Example:</p> <pre><code>// generates a string consisting of only uppercase/lowercase alphabets/numeric characters\nauto stringGen = gen::derive&lt;int, std::string&gt;(\n    gen::interval(0, 2),\n    [](const int&amp; num) {\n        if (num == 0)\n            return gen::string(gen::interval('A', 'Z'));\n        else if (num == 1)\n            return gen::string(gen::interval('a', 'z'));\n        else // num == 2\n            return gen::string(gen::interval('0', '9'));\n    }\n);\n</code></pre> <p>Comparison with <code>gen::transform</code>:</p> Combinator Transformer Signature Result Type <code>gen::transform&lt;T,U&gt;</code> <code>function&lt;U(T)&gt;</code> <code>Generator&lt;U&gt;</code> <code>gen::derive&lt;T,U&gt;</code> <code>function&lt;Generator&lt;U&gt;(T)&gt;</code> <code>Generator&lt;U&gt;</code> <p>See also: Transforming or Mapping, Utility Methods for fluent chaining with <code>.flatMap&lt;U&gt;()</code></p>"},{"location":"Combinators/#values-with-dependencies","title":"Values with Dependencies","text":"<p>Generate values where one value depends on another. Two combinators facilitate this: one generates a <code>std::pair</code>, and the other generates a <code>std::tuple</code>.</p>"},{"location":"Combinators/#gendependencytu","title":"<code>gen::dependency&lt;T,U&gt;</code>","text":"<p>Underlying implementation of <code>.pairWith&lt;U&gt;()</code>.</p> <p>Generates a <code>std::pair&lt;T,U&gt;</code>. It first uses <code>genT</code> to generate a value of type <code>T</code>. This value is then passed to <code>genUgen</code>, which is a function that returns a <code>Generator&lt;U&gt;</code>. This returned generator produces the second element of the pair. This effectively creates a generator for a pair where the second item depends on the first.</p> <p>Signature: <code>gen::dependency&lt;T,U&gt;(genT, genUgen)</code></p> <p>Example:</p> <pre><code>// Example 1: Generate a size and a vector of that size\nauto sizeAndVectorGen = gen::dependency&lt;int, std::vector&lt;bool&gt;&gt;(\n    gen::interval(1, 100),\n    [](const int&amp; size) {\n        auto vectorGen = gen::vector&lt;bool&gt;();\n        vectorGen.setSize(size);\n        return vectorGen; // generates a vector with exactly 'size' elements\n    }\n);\n\n// Example 2: Generate a bool and an int depending on the bool\nauto nullableIntegerGen = gen::dependency&lt;bool, int&gt;(\n    gen::boolean(),\n    [](const bool&amp; isNull) -&gt; Generator&lt;int&gt; {\n        if (isNull)\n            return gen::just(0);\n        else\n            return gen::interval(10, 20);\n    }\n);\n</code></pre> <p>See also: Utility Methods for fluent chaining with <code>.pairWith&lt;U&gt;()</code></p>"},{"location":"Combinators/#genchaintsu","title":"<code>gen::chain&lt;Ts...,U&gt;</code>","text":"<p>Underlying implementation of <code>.tupleWith&lt;U&gt;()</code>. Similar to <code>gen::dependency</code>, but operates on tuples. It takes a generator <code>genTuple</code> for <code>std::tuple&lt;Ts...&gt;</code> and a function <code>genUFromTuple</code>. This function receives the generated tuple (<code>const std::tuple&lt;Ts...&gt;&amp;</code>) and returns a <code>Generator&lt;U&gt;</code>. The final result is a generator for <code>std::tuple&lt;Ts..., U&gt;</code>. <code>gen::chain</code> can be repeatedly applied to build tuples with multiple dependent elements.</p> <p>Signature: <code>gen::chain&lt;Ts..., U&gt;(genTuple, genUFromTuple)</code></p> <p>Example:</p> <pre><code>auto yearMonthGen = gen::tuple(gen::interval(1900, 2100), gen::interval(1, 12));\n// number of days in a month depends on the month and whether the year is a leap year\nauto yearMonthDayGen = gen::chain&lt;int, int, int&gt;(\n    yearMonthGen,\n    [](const std::tuple&lt;int, int&gt;&amp; yearMonth) -&gt; Generator&lt;int&gt; {\n        int year = std::get&lt;0&gt;(yearMonth);\n        int month = std::get&lt;1&gt;(yearMonth);\n        if (monthHas31Days(month)) {\n            return gen::interval(1, 31);\n        } else if (monthHas30Days(month)) {\n            return gen::interval(1, 30);\n        } else { // February (month == 2)\n            if (isLeapYear(year))\n                return gen::interval(1, 29);\n            else\n                return gen::interval(1, 28);\n        }\n    }\n); // yearMonthDayGen generates std::tuple&lt;int, int, int&gt; representing (year, month, day)\n</code></pre> <p>See also: Utility Methods for fluent chaining with <code>.tupleWith&lt;U&gt;()</code></p> <p>Alternative Approach with <code>gen::filter</code>:</p> <p>You can often achieve similar goals using the <code>gen::filter</code> combinator:</p> <pre><code>// generate any year, month, day combination first\nauto anyYearMonthDayGen = gen::tuple(\n    gen::interval(1900, 2100),\n    gen::interval(1, 12),\n    gen::interval(1, 31)\n);\n// then apply filter to keep only valid dates\nauto validYearMonthDayGen = anyYearMonthDayGen.filter([](const std::tuple&lt;int, int, int&gt;&amp; ymd) {\n    int year = std::get&lt;0&gt;(ymd);\n    int month = std::get&lt;1&gt;(ymd);\n    int day = std::get&lt;2&gt;(ymd);\n    return isValidDate(year, month, day); // Assuming isValidDate helper function\n});\n</code></pre> <p>However, using <code>gen::filter</code> for generating values with complex dependencies can be inefficient. If the constraints are tight, many generated values might be discarded before a valid one is found, leading to performance issues. In such cases, <code>gen::dependency</code> or <code>gen::chain</code> are often preferable as they construct valid values directly.</p>"},{"location":"Combinators/#aggregation-or-accumulation-of-values","title":"Aggregation or Accumulation of Values","text":"<p>Generate sequences of values where each value depends on the previously generated one(s). A common example is generating a sequence of chess moves, where knowing the previous move is crucial for generating the next valid move.</p> <p>Both combinators take: 1. A base generator (<code>genT</code>) for the initial value. 2. A function (<code>genTFromT</code>) that receives the previously generated value of type <code>T</code> and returns a <code>Generator&lt;T&gt;</code> for the next value in the sequence. 3. Minimum (<code>minSize</code>) and maximum (<code>maxSize</code>) lengths for the generated sequence.</p> Combinator Result Type Description <code>gen::accumulate&lt;T&gt;(genT, genTFromT, minSize, maxSize)</code> <code>Generator&lt;T&gt;</code> Generates sequence, returns the last element <code>gen::aggregate&lt;T&gt;(genT, genTFromT, minSize, maxSize)</code> <code>Generator&lt;vector&lt;T&gt;&gt;</code> Generates sequence, returns the entire sequence vector"},{"location":"Combinators/#genaccumulatet","title":"<code>gen::accumulate&lt;T&gt;</code>","text":"<p>Generates a sequence of values based on the previous one, but ultimately yields only the final value generated in that sequence.</p> <p>Signature: <code>gen::accumulate&lt;T&gt;(genT, genTFromT, minSize, maxSize)</code></p> <p>Example:</p> <pre><code>// generate initial value\nauto baseGen = gen::interval(0, 1000);\n// generate a value based on previous value, return only the last one\nGenerator&lt;int&gt; gen = gen::accumulate&lt;int&gt;(\n    baseGen,\n    [](const int&amp; num) {\n        // Generate next number between 0.5x and 1.5x of the previous\n        // Ensure lower bound is not negative if num is small\n        int lower = std::max(0, num / 2);\n        int upper = num + num / 2;\n        return gen::interval(lower, upper);\n    },\n    2 /* min sequence length */,\n    10 /* max sequence length */\n);\n</code></pre>"},{"location":"Combinators/#genaggregatet","title":"<code>gen::aggregate&lt;T&gt;</code>","text":"<p>Generates a sequence of values where each depends on the previous, and yields the entire sequence as a <code>std::vector&lt;T&gt;</code>.</p> <p>Signature: <code>gen::aggregate&lt;T&gt;(genT, genTFromT, minSize, maxSize)</code></p> <p>Example:</p> <pre><code>// generate initial value\nauto baseGen = gen::interval(100, 1000); // Ensure initial value is not too small for division\n// generate list of values where each depends on the previous\nGenerator&lt;vector&lt;int&gt;&gt; gen = gen::aggregate&lt;int&gt;(\n    baseGen,\n    [](int num) {\n        // Generate next number between 0.5x and 1.5x of the previous\n        int lower = std::max(0, num / 2);\n        int upper = num + num / 2;\n        return gen::interval(lower, upper);\n    },\n    2 /* min sequence length */,\n    10 /* max sequence length */\n);\n</code></pre> <p>See also: StatefulTesting.md for testing stateful systems with sequences of actions</p> <p> </p>"},{"location":"Combinators/#related-topics","title":"Related Topics","text":"<ul> <li>Generators.md - Comprehensive reference for all built-in generators</li> <li>Arbitrary.md - Default generators for common types</li> <li>CustomGenerator.md - Creating custom generators with built-in constraints</li> <li>Walkthrough.md - Step-by-step guide for creating property tests</li> <li>PropertyAPI.md - API reference for property-based tests</li> <li>StatefulTesting.md - Testing stateful systems with sequences of actions</li> </ul>"},{"location":"ConcurrencyTesting/","title":"Concurrency Testing","text":"<p>Once you're familiar with stateful testing, you can get acquainted with concurrent stateful testing easily. Concurrency testing performs interleaved state transitions using multiple threads in parallel. It allows us to see if any anomaly or breaking of concurrency requirement in the tested component.</p> <p>Actually, a concurrency test is almost immediately achievable when you have prepared a stateful test for an object type. Following depicts a concurrent test for <code>std::vector&lt;int&gt;</code> with <code>push_back(int)</code>, <code>pop_back()</code>, and <code>clear()</code> actions included.</p> <pre><code>#include \"proptest/proptest.hpp\"\n#include \"proptest/concurrencytest.hpp\"\n\nusing namespace proptest;\nusing namespace proptest::concurrent;\n\n// ...\n\nauto pushBackGen = gen::int32().map&lt;SimpleAction&lt;std::vector&lt;int&gt;&gt;&gt;([](const int&amp; value) {\n    return [value](const std::vector&lt;int&gt;&amp; obj) {\n        obj.push_back(value);\n        return true;\n    };\n});\n\nauto popBackGen = gen::just&lt;SimpleAction&lt;std::vector&lt;int&gt;&gt;&gt;([](const std::vector&lt;int&gt;&amp; obj) {\n    if (obj.empty())\n        return true;\n    obj.pop_back();\n    return true;\n});\n\nauto clearGen = gen::just&lt;SimpleAction&lt;std::vector&lt;int&gt;&gt;&gt;([](const std::vector&lt;int&gt;&amp; obj) {\n    obj.clear();\n    return true;\n});\n\nauto actionListGen = actionListGenOf&lt;std::vector&lt;int&gt;&gt;(pushBackGen, popBackGen, clearGen);\nauto concurrentProp = concurrency&lt;std::vector&lt;int&gt;&gt;(gen::vector&lt;int&gt;(), actionListGen);\nconcurrentProp.go();\n</code></pre> <p>You may have noticed that, above test would lead to exceptions or crashes, as <code>std::vector</code> is not made for concurrent writes, unless some synchronization mechanism is present.</p> <p>You can also add a post-check to be performed after each concurrent test run, by setting a post-check function to concurrent property with <code>setPostCheck()</code> method:</p> <pre><code>concurrentProp.setPostCheck([](std::vector&lt;int&gt;&amp; obj) {\n    // ... post-check. perform some consistency check for obj\n}).go();\n\n// variant with a model\nconcurrentProp.setPostCheck([](std::vector&lt;int&gt;&amp; obj, VectorModel&amp; model) {\n    // ... post-check. perform some consistency check for obj against model\n}).go();\n</code></pre> <p>While you can perform checks in some of the actions, it's sometimes better to have a post-check instead. In concurrent tests, your model as well as the stateful object can be concurrently accessed. Adding synchronization primitives for model object can cause unintended serialization to occur on the stateful object, too. This is why a post-check comes handy, as you don't need to care about synchronization since it's performed after all actions are finished and threads are joined.</p> <pre><code>\n</code></pre>"},{"location":"CustomGenerator/","title":"Building Custom Generator from Scratch","text":"<p>New to property-based testing? Start with the Walkthrough for a step-by-step guide. Before building a custom generator from scratch, consider combining existing generators with combinators\u2014<code>.filter()</code>, <code>.map&lt;U&gt;()</code>, <code>.flatMap&lt;U&gt;()</code>, <code>.pairWith&lt;U&gt;()</code>, or gen::construct often suffice. Build from scratch only when you need generation logic that cannot be expressed by composing these.</p> <p> </p>"},{"location":"CustomGenerator/#when-to-build-from-scratch","title":"When to Build from Scratch","text":"<p>Custom generators are useful when:</p> <ul> <li>You need values from a domain not covered by built-in generators or Arbitraries</li> <li>Combinators (filter, map, flatMap, construct) cannot express your constraints or transformations</li> <li>You need custom shrinking behavior (see Shrinking)</li> <li>You want to define a default generator for a type used across many tests (see Arbitrary)</li> </ul> <p> </p>"},{"location":"CustomGenerator/#generatort-and-arbitraryt","title":"<code>Generator&lt;T&gt;</code> and <code>Arbitrary&lt;T&gt;</code>","text":"<p><code>Generator&lt;T&gt;</code> and <code>Arbitrary&lt;T&gt;</code> are the standard generator types in <code>cppproptest</code>. Both share the same chainable utility methods (<code>.filter()</code>, <code>.map&lt;U&gt;()</code>, <code>.flatMap&lt;U&gt;()</code>, etc.). <code>Generator&lt;T&gt;</code> is commonly the result of combinators; <code>Arbitrary&lt;T&gt;</code> is the default generator for a type. They are fully chainable\u2014you can use any generator with <code>forAll</code> and chain methods as needed.</p> <p> </p>"},{"location":"CustomGenerator/#building-a-custom-generator","title":"Building a Custom Generator","text":"<p>A generator in <code>cppproptest</code> is simply a callable with signature <code>(Random&amp;) -&gt; Shrinkable&lt;T&gt;</code>. Simplest way to make a shrinkable is to use <code>make_shrinkable&lt;T&gt;(value)</code> to wrap your value. This makes a shrinkable with no further shrinks. See Shrinking for details on <code>Shrinkable</code>.</p> <p>You can wrap your callable with <code>Generator&lt;T&gt;</code> to decorate it as a standard generator with same chainable utility methods as built-in generators and Arbitraries:</p> <pre><code>auto myIntGen = Generator&lt;int&gt;([](Random&amp; rand) {\n    int smallInt = rand.getRandomInt8();\n    return make_shrinkable&lt;int&gt;(smallInt);\n});\n\n// Chain with .filter(), .map(), etc. like any other standard generators\nauto evenGen = myIntGen.filter([](const int&amp; value) {\n    return value % 2 == 0;\n});\n</code></pre> <p> </p>"},{"location":"CustomGenerator/#related-topics","title":"Related Topics","text":"<ul> <li>Combinators - <code>.filter()</code>, <code>.map()</code>, <code>.flatMap()</code>, and other utility methods for transforming generators</li> <li>Generators - Built-in generators for primitives and containers</li> <li>Arbitrary - Defining default generators for types used in <code>forAll</code> without explicit generator arguments</li> <li>Shrinking - How <code>Shrinkable</code> and <code>make_shrinkable</code> enable automated simplification of failing inputs</li> <li>Property API - Using custom generators with <code>forAll</code> and <code>property()</code></li> <li>Walkthrough - Step-by-step guide for creating property tests</li> </ul>"},{"location":"GenNamespace/","title":"The <code>gen</code> Namespace","text":"<p>The <code>gen</code> namespace provides convenient collection for all built-in generators and combinators in <code>cppproptest</code>. The <code>gen</code> namespace is designed to provide a unified, user-friendly interface for accessing generators and combinators. Instead of writing verbose built-in arbitrary names like <code>Arbi&lt;int&gt;()</code>, you can use more intuitive names like <code>gen::int32()</code> or <code>gen::arbitrary&lt;int&gt;</code>.</p> <p>Note: All functions in the <code>gen</code> namespace are aliases to the original <code>proptest</code> namespace functions. The original names remain available for backward compatibility.</p>"},{"location":"GenNamespace/#generators","title":"Generators","text":"<p>To use the <code>gen</code> namespace, simply include the main header and use the <code>gen::</code> prefix:</p> <pre><code>#include \"proptest/proptest.hpp\"\n\nusing namespace proptest;\n\n// Use gen namespace for cleaner syntax\nauto intGen = gen::int32();\nauto stringGen = gen::string();\nauto vectorGen = gen::vector&lt;int&gt;();\n</code></pre>"},{"location":"GenNamespace/#combinators","title":"Combinators","text":"<pre><code>// Constants and choices\nauto constantGen = gen::just(42);\nauto choiceGen = gen::elementOf&lt;int&gt;(1, 3, 5, 7, 11, 13, 17, 19);\nauto unionGen = gen::oneOf&lt;int&gt;(\n    gen::interval&lt;int&gt;(1, 10),\n    gen::interval&lt;int&gt;(100, 110)\n);\n\n// Object construction\nstruct Point { Point(int x, int y) : x(x), y(y) {} int x, y; };\nauto pointGen = gen::construct&lt;Point, int, int&gt;(\n    gen::interval&lt;int&gt;(-10, 10),\n    gen::interval&lt;int&gt;(-10, 10)\n);\n\n// Filtering and transformation\nauto evenGen = gen::filter&lt;int&gt;(gen::int32(), [](int n) { return n % 2 == 0; });\nauto positiveGen = gen::suchThat&lt;int&gt;(gen::int32(), [](int n) { return n &gt; 0; });\nauto stringFromIntGen = gen::transform&lt;int, std::string&gt;(\n    gen::int32(),\n    [](int n) { return std::to_string(n); }\n);\n</code></pre>"},{"location":"GenNamespace/#dependencies-and-complex-generators","title":"Dependencies and Complex Generators","text":"<pre><code>// Size-dependent vector\nauto sizeAndVectorGen = gen::dependency&lt;int, std::vector&lt;int&gt;&gt;(\n    gen::interval&lt;int&gt;(1, 5),\n    [](int size) { return gen::vector&lt;int&gt;().setSize(size); }\n);\n\n// Complex nested structure\nauto complexGen = gen::vector&lt;gen::map&lt;std::string, gen::vector&lt;int&gt;&gt;&gt;();\n</code></pre>"},{"location":"GenNamespace/#property-tests","title":"Property Tests","text":"<pre><code>// Simple property test\nforAll([](int x, int y) {\n    return x + y == y + x;  // Commutativity of addition\n}, gen::interval&lt;int&gt;(-100, 100), gen::interval&lt;int&gt;(-100, 100));\n\n// Property test with custom generators\nforAll([](std::vector&lt;int&gt; vec) {\n    if (vec.empty()) return true;\n    auto sorted = vec;\n    std::sort(sorted.begin(), sorted.end());\n    return sorted.size() == vec.size();\n}, gen::vector&lt;int&gt;().setSize(0, 10));\n</code></pre>"},{"location":"GeneratorExamples/","title":"Generating Real-World Inputs","text":"<p>Obtaining a suitable generator for your property test is crucial. This page provides realistic examples of generating complex inputs.</p>"},{"location":"GeneratorExamples/#generating-a-valid-date","title":"Generating a valid <code>Date</code>","text":"<ul> <li>A proper Date representation based on number of days in a month</li> <li>A day of a month should be in range between 1 to 31, while considering which month and year it is, to have correct maximum value among 28, 29, 30, and 31.</li> </ul> <pre><code>bool isLeapYear(int year) {\n  if (year % 4 != 0) {\n    return false;\n  } else if (year % 100 == 0) {\n    return (year % 400 == 0); // Century year check\n  } else {\n    return true;\n  }\n}\n\nint getMaximumDay(int year, int month) {\n    // February Handling with Leap Year Information\n    if (month == 2) {\n        return isLeapYear(year) ? 29 : 28;\n    }\n    // 30-day Months\n    if (month == 4 || month == 6 || month == 9 || month == 11) {\n        return 30;\n    }\n    // All other months have 31 days\n    return 31;\n}\n\nauto yearMonthGen = gen::tuple(gen::interval(0, 9999), gen::interval(1,12));\n\n// combines (int,int) and int into (int,int,int)\nauto dateTupleGen = yearMonthGen.tupleWith([](const std::tuple&lt;int, int&gt; yearMonth) {\n    int year = std::get&lt;0&gt;(yearMonth);\n    int month = std::get&lt;1&gt;(yearMonth);\n    auto dayGen = gen::interval(1, getMaximumDay(year, month));\n    return dayGen;\n});\n</code></pre>"},{"location":"GeneratorExamples/#generating-a-fixed-point-decimal-with-precision-p-and-scale-s","title":"Generating a fixed point decimal with precision <code>p</code> and scale <code>s</code>","text":"<ul> <li>A <code>Decimal(p, s)</code> is a fixed point decimal with a precision <code>p</code> and a scale <code>s</code>.</li> <li>It means there are <code>p</code> number of digits with <code>s</code> number of decimals, like <code>123.45</code> being a <code>Decimal(5,2)</code>.</li> <li>We can first generate <code>p - s</code> number of numeric characters that does not start with <code>'0'</code>.</li> <li>Then we can generate rest <code>s</code> number of numeric characters and concatenate the two strings with <code>.</code>.</li> <li>We can generate a sign character in front of the new string to complete the decimal*</li> </ul> <pre><code>    auto precisionGen = gen::interval(1, maxPrecision);\n    auto scaleGen = gen::interval(minScale, maxScale);\n    auto tupleGen = gen::tuple(precisionGen, scaleGen);\n\n    auto decimalGen = tupleGen.template flatMap&lt;Decimal&gt;([](const std::tuple&lt;int, int&gt;&amp; tup) -&gt; GenFunction&lt;federation::Decimal&gt; {\n        int precision = std::get&lt;0&gt;(tup);\n        int scale = std::get&lt;1&gt;(tup);\n        // decide digits of precision\n        auto signGen = gen::boolean(); // true: neg, false: pos\n        auto firstGen = gen::interval&lt;char&gt;('1', '9');\n        auto stringGen = gen::string(gen::interval('0', '9'));\n        stringGen.setSize(precision-1);\n        auto decTupleGen = gen::tuple(signGen, firstGen, stringGen);\n        return decTupleGen.map&lt;federation::Decimal&gt;([scale](const ltt::tuple&lt;bool, char, _STL::string&gt;&amp; decTup) {\n            bool isNeg = std::get&lt;0&gt;(decTup);\n            char first = std::get&lt;1&gt;(decTup);\n            std::string rest = std::get&lt;2&gt;(decTup);\n            std::stringstream digits;\n            digits &lt;&lt; first &lt;&lt; rest;\n            return Decimal(digits.str(), scale, isNeg);\n        });\n    });\n</code></pre>"},{"location":"GeneratorExamples/#generating-a-chess-move","title":"Generating a chess move","text":"<ul> <li>A legitimate chess move follows complex rules based on previous state and action<ul> <li>A board configuration is given as previous state</li> <li>Last move is given as previous action</li> </ul> </li> </ul> <pre><code>using GenT = std::pair&lt;ChessBoard, ChessMove&gt;;\n\nauto genT = gen::just(std::make_pair(\n    ChessBoard::initialBoard(), // Function to create a starting chessboard\n    ChessMove::nullMove()       // Placeholder for the initial move\n));\n\nauto gen2GenT = [](const std::pair&lt;ChessBoard, ChessMove&gt;&amp; prev) {\n  // 1. Extract the ChessBoard from 'prev'.\n  const ChessBoard&amp; currentBoard = prev.first;\n\n  // 2. Generate a list of LEGAL moves from the 'currentBoard'.\n  auto legalMoves = generateLegalMoves(currentBoard);\n\n  // 3. Create a generator that selects from 'legalMoves'.\n  auto moveGen = gen::elementOf(legalMoves);\n\n  // 4.  For each chosen 'move', apply it to 'currentBoard'\n  //     to get the new board state.\n  return moveGen.map([currentBoard](const ChessMove&amp; move) {\n    ChessBoard newBoard = currentBoard.applyMove(move);\n    return std::make_pair(newBoard, move);\n  });\n};\n\nusing GenT2GenT = decltype(gen2GenT);\n\nauto chessMoveSequenceGen = gen::accumulate&lt;GenT, GenT2GenT&gt;(genT, gen2GenT, minSize, maxSize);\n</code></pre>"},{"location":"Generators/","title":"Generators","text":"<p>New to property-based testing? Start with the Walkthrough for a step-by-step guide. This page provides a comprehensive reference for all built-in generators in <code>cppproptest</code>.</p> <p>Generators are the foundation of property-based testing in <code>cppproptest</code>. They define the input domain of a property by specifying how random values should be generated. A generator is essentially a function that produces random values according to defined constraints.</p>"},{"location":"Generators/#generator-quick-reference","title":"Generator Quick Reference","text":"<p>The following table provides a comprehensive overview of all generators available in <code>cppproptest</code>, organized by category. Click on any generator name to jump to its detailed documentation.</p> Category Generator Description Primitives <code>gen::boolean</code> Boolean values <code>gen::character</code> Character values <code>gen::int8</code>, <code>gen::uint8</code>, <code>gen::int16</code>, <code>gen::uint16</code>, <code>gen::int32</code>, <code>gen::uint32</code>, <code>gen::int64</code>, <code>gen::uint64</code> Integer types (8, 16, 32, 64-bit) <code>gen::float32</code>, <code>gen::float64</code> Floating point numbers Strings <code>gen::string</code> ASCII strings <code>gen::utf8string</code> UTF-8 strings <code>gen::utf16bestring</code>, <code>gen::utf16lestring</code> UTF-16 strings (big-endian, little-endian) <code>gen::cesu8string</code> CESU-8 strings Containers <code>gen::vector&lt;T&gt;</code> Vectors <code>gen::list&lt;T&gt;</code> Lists <code>gen::set&lt;T&gt;</code> Sets <code>gen::map&lt;K,V&gt;</code> Maps <code>gen::optional&lt;T&gt;</code> Optional values <code>gen::shared_ptr&lt;T&gt;</code> Shared pointers Tuples &amp; Pairs <code>gen::pair&lt;T1,T2&gt;</code> Pairs <code>gen::tuple&lt;Ts...&gt;</code> Tuples Numeric Ranges <code>gen::natural&lt;T&gt;(max)</code> Positive integers \u2264 max <code>gen::nonNegative&lt;T&gt;(max)</code> Non-negative integers \u2264 max <code>gen::interval&lt;T&gt;(min, max)</code> Integers in [min, max] <code>gen::inRange&lt;T&gt;(from, to)</code> Integers in [from, to) <code>gen::integers&lt;T&gt;(start, count)</code> Integers in [start, start+count) Intervals <code>gen::intervals({...})</code> Multiple intervals (signed) <code>gen::uintervals({...})</code> Multiple intervals (unsigned) Combinators <code>gen::just&lt;T&gt;(value)</code> Constant value <code>gen::elementOf&lt;T&gt;(vals...)</code> Random selection from values <code>gen::oneOf&lt;T&gt;(gens...)</code> Union of generators <code>gen::unionOf&lt;T&gt;(gens...)</code> Alias for <code>gen::oneOf</code> <code>gen::construct&lt;Class,Args...&gt;(gens...)</code> Object construction <code>gen::transform&lt;T,U&gt;(gen, func)</code> Value transformation <code>gen::derive&lt;T,U&gt;(gen, genGen)</code> Value derivation (flat-map) <code>gen::filter&lt;T&gt;(gen, predicate)</code> Value filtering <code>gen::suchThat&lt;T&gt;(gen, predicate)</code> Alias for filter <code>gen::dependency&lt;T,U&gt;(genT, genUGen)</code> Dependency between values <code>gen::chain&lt;T&gt;(genT, genGen)</code> Chain of generators <code>gen::aggregate&lt;T&gt;(genT, aggregator)</code> Aggregation of values <code>gen::accumulate&lt;T&gt;(genT, accumulator, min, max)</code> Accumulation of values <code>gen::lazy&lt;T&gt;(func)</code> Lazy evaluation <code>gen::reference&lt;T&gt;(ref)</code> Reference wrapper <code>gen::weighted&lt;T&gt;(gen, weight)</code> Weighted generator decorator <code>gen::weightedVal&lt;T&gt;(value, weight)</code> Weighted value decorator Utilities <code>gen::arbitrary&lt;T&gt;(...)</code> Access to arbitrary <code>gen::noShrink(gen)</code> Same values, but with empty shrink stream <p>Note: For detailed documentation on combinators, see the Combinators page. For building custom generators, see Custom Generator.</p>"},{"location":"Generators/#generators-in-property-based-testing","title":"Generators in Property-Based Testing","text":"<p>Property-based testing promotes the concept of input domain of a property. In property-based testing, generators are the means for representing input domains. Even a simple <code>forAll()</code> call depends on generators under the hood. Consider the following example:</p> <pre><code>forAll([](int age, std::string name) {\n    // Property test code\n});\n</code></pre> <p>This <code>forAll()</code> call takes a function with parameters of types <code>int</code> and <code>std::string</code>. This function is the property function. If no additional specification is given on how to generate the values for <code>age</code> and <code>name</code> as in this example, the parameter types are identified to invoke the default generators for those types. In this case, it calls the default generators for <code>int</code> and <code>std::string</code> types.</p> <p>Those default generators are called the arbitraries. You can access the arbitraries of a type <code>T</code> with <code>Arbitrary&lt;T&gt;</code> or <code>Arbi&lt;T&gt;</code>. Previous code is actually equivalent to:</p> <pre><code>forAll([](int age, std::string name) {\n    // Property test code\n}, Arbitrary&lt;int&gt;(), Arbitrary&lt;std::string&gt;());\n</code></pre> <p>Notice the extra arguments <code>gen::arbitrary&lt;int&gt;()</code> and <code>gen::arbitrary&lt;std::string&gt;()</code> in the <code>forAll()</code> call. As you can see, <code>forAll()</code> actually requires some information on how to generate the values for the parameter types. Some of the commonly used data types have default generators defined in <code>cppproptest</code>.</p> <p><code>gen</code> namespace also provide alias template <code>gen::arbitrary&lt;T&gt;</code>. So you can also write the same code as:</p> <pre><code>forAll([](int age, std::string name) {\n    // Property test code\n}, gen::arbitrary&lt;int&gt;(), gen:arbitrary&lt;std::string&gt;());\n</code></pre> <p>See also: Arbitrary for details on default generators, Property API Reference for <code>forAll()</code> usage, and Walkthrough for step-by-step examples.</p>"},{"location":"Generators/#built-in-arbitraries-and-their-generator-aliases","title":"Built-in Arbitraries and Their Generator Aliases","text":"<p>Specifically for <code>Arbitrary&lt;int&gt;()</code> in the above example, we have an alias - <code>gen::int32()</code>. <code>cppproptest</code> provides such built-in arbitraries for common data types and useful aliases to those arbitraries in the <code>gen</code> namespace. Thus, you can also write the above example as following:</p> <pre><code>forAll([](int age, std::string name) {\n    // Property test code\n}, gen::int32(), gen::string());\n</code></pre> <p>Here is the complete list of the built-in arbitraries and their aliases. You can also refer to the Arbitrary page for more about arbitraries, including their configurable options and how they make up as default generators for a data type.</p> <p>See also: Gen Namespace for details on the <code>gen</code> namespace organization.</p>"},{"location":"Generators/#basic-type-generators","title":"Basic Type Generators","text":"Alias Arbitrary Description <code>gen::boolean</code> <code>Arbi&lt;bool&gt;</code> Boolean values <code>gen::character</code> <code>Arbi&lt;char&gt;</code> Character values <code>gen::int8</code>, <code>gen::uint8</code>, <code>gen::int16</code>, <code>gen::uint16</code>, <code>gen::int32</code>, <code>gen::uint32</code>, <code>gen::int64</code>, <code>gen::uint64</code> <code>Arbi&lt;int8_t&gt;</code>, <code>Arbi&lt;uint8_t&gt;</code>, <code>Arbi&lt;int16_t&gt;</code>, <code>Arbi&lt;uint16_t&gt;</code>, <code>Arbi&lt;int32_t&gt;</code>, <code>Arbi&lt;uint32_t&gt;</code>, <code>Arbi&lt;int64_t&gt;</code>, <code>Arbi&lt;uint64_t&gt;</code> Integer types (8, 16, 32, 64-bit) <code>gen::float32</code>, <code>gen::float64</code> <code>Arbi&lt;float&gt;</code>, <code>Arbi&lt;double&gt;</code> Floating point numbers"},{"location":"Generators/#genboolean","title":"<code>gen::boolean</code>","text":"<p>Generates random boolean values (<code>true</code> or <code>false</code>) with configurable probability.</p> <p>Parameters:</p> <ul> <li><code>trueProb</code> (double, default: 0.5): Probability of generating <code>true</code> (0.0 to 1.0)</li> </ul> <p>Returns: <code>Generator&lt;bool&gt;</code></p> <p>Examples: <pre><code>// Generate random booleans (50% true, 50% false)\nauto boolGen = gen::boolean();\n\n// Generate mostly true values (80% true, 20% false)\nauto boolGen = gen::boolean(0.8);\n\n// Usage in forAll\nforAll([](bool b) {\n    // Property test with booleans\n}, gen::boolean());\n</code></pre></p> <p>See also: Arbitrary for configuration options.</p>"},{"location":"Generators/#gencharacter","title":"<code>gen::character</code>","text":"<p>Generates random character values.</p> <p>Parameters:</p> <ul> <li>None</li> </ul> <p>Returns: <code>Generator&lt;char&gt;</code></p> <p>Examples: <pre><code>// Generate random characters\nauto charGen = gen::character();\n\n// Usage in forAll\nforAll([](char c) {\n    // Property test with characters\n}, gen::character());\n</code></pre></p> <p>See also: Arbitrary for configuration options, String Generators for string generation.</p>"},{"location":"Generators/#integer-generators","title":"Integer Generators","text":"<p>Generate signed and unsigned integers of various bit widths: <code>gen::int8</code>, <code>gen::uint8</code>, <code>gen::int16</code>, <code>gen::uint16</code>, <code>gen::int32</code>, <code>gen::uint32</code>, <code>gen::int64</code>, <code>gen::uint64</code>.</p> <p>Parameters:</p> <ul> <li>None</li> </ul> <p>Returns: <code>Generator&lt;int8_t&gt;</code>, <code>Generator&lt;uint8_t&gt;</code>, <code>Generator&lt;int16_t&gt;</code>, <code>Generator&lt;uint16_t&gt;</code>, <code>Generator&lt;int32_t&gt;</code>, <code>Generator&lt;uint32_t&gt;</code>, <code>Generator&lt;int64_t&gt;</code>, or <code>Generator&lt;uint64_t&gt;</code></p> <p>Examples: <pre><code>// Generate integers of various sizes\nauto int8Gen = gen::int8();\nauto uint8Gen = gen::uint8();\nauto int16Gen = gen::int16();\nauto uint16Gen = gen::uint16();\nauto int32Gen = gen::int32();\nauto uint32Gen = gen::uint32();\nauto int64Gen = gen::int64();\nauto uint64Gen = gen::uint64();\n\n// Usage in forAll\nforAll([](int32_t i, uint32_t u) {\n    // Property test with integers\n}, gen::int32(), gen::uint32());\n</code></pre></p> <p>See also: Arbitrary for configuration options.</p>"},{"location":"Generators/#utility-numeric-range-generators","title":"Utility Numeric Range Generators","text":"<p>There are also utility integer generators based on numeric range for everyday use. These are function calls, not type aliases. The first three (<code>gen::interval</code>, <code>gen::inRange</code>, <code>gen::integers</code>) are essentially the same concept with different parameter styles and inclusive/exclusive semantics, so you can choose based on preference and clarity.</p> Alias Description <code>gen::interval&lt;T&gt;(min, max)</code> Integers in [min, max] (inclusive) <code>gen::inRange&lt;T&gt;(from, to)</code> Integers in [from, to) (exclusive) <code>gen::integers&lt;T&gt;(start, count)</code> Integers in [start, start+count) <code>gen::natural&lt;T&gt;(max)</code> Positive integers \u2264 max <code>gen::nonNegative&lt;T&gt;(max)</code> Non-negative integers \u2264 max"},{"location":"Generators/#genintervaltmin-max","title":"<code>gen::interval&lt;T&gt;(min, max)</code>","text":"<p>Generates integers in the range [min, max] (inclusive of both bounds).</p> <p>Parameters:</p> <ul> <li><code>min</code> (T): Minimum integer value (inclusive)</li> <li><code>max</code> (T): Maximum integer value (inclusive)</li> </ul> <p>Returns: <code>Generator&lt;T&gt;</code></p> <p>Examples: <pre><code>// Generate integers from 1 to 100\nauto smallIntGen = gen::interval&lt;int&gt;(1, 100);\n\n// Different integer types\nauto smallInt8Gen = gen::interval&lt;int8_t&gt;(-128, 127);\nauto int64Gen = gen::interval&lt;int64_t&gt;(-1000000, 1000000);\n\n// Usage in forAll\nforAll([](int small) {\n    // Property test with range-constrained integers\n}, gen::interval&lt;int&gt;(1, 100));\n</code></pre></p> <p>See also: Basic Type Generators for integer type generators, gen::inRange(from, to) for exclusive ranges, Interval Generators for multiple intervals."},{"location":"Generators/#geninrangetfrom-to","title":"<code>gen::inRange&lt;T&gt;(from, to)</code>","text":"<p>Generates integers in the range [from, to) (exclusive of <code>to</code>).</p> <p>Parameters:</p> <ul> <li><code>from</code> (T): Minimum integer value (inclusive)</li> <li><code>to</code> (T): Maximum integer value (exclusive)</li> </ul> <p>Returns: <code>Generator&lt;T&gt;</code></p> <p>Examples: <pre><code>// Generate integers from 0 to 99 (exclusive of 100)\nauto rangeIntGen = gen::inRange&lt;int&gt;(0, 100);\n\n// Usage in forAll\nforAll([](int index) {\n    // Property test with range-constrained integers\n}, gen::inRange&lt;int&gt;(0, 100));\n</code></pre></p> <p>See also: Basic Type Generators for integer type generators, gen::interval(min, max) for inclusive ranges."},{"location":"Generators/#genintegerststart-count","title":"<code>gen::integers&lt;T&gt;(start, count)</code>","text":"<p>Generates integers in the range [start, start+count). The second parameter is the count of values to generate, not the maximum value.</p> <p>Parameters:</p> <ul> <li><code>start</code> (T): Starting value (inclusive)</li> <li><code>count</code> (T): Number of values to generate (must be positive)</li> </ul> <p>Returns: <code>Generator&lt;T&gt;</code></p> <p>Examples: <pre><code>// Generate integers from 10 to 29 (20 values)\nauto sequenceIntGen = gen::integers&lt;int&gt;(10, 20);\n\n// Usage in forAll\nforAll([](int value) {\n    // Property test with sequence integers\n}, gen::integers&lt;int&gt;(10, 20));\n</code></pre></p> <p>See also: Basic Type Generators for integer type generators, gen::interval(min, max) for inclusive ranges."},{"location":"Generators/#gennaturaltmax","title":"<code>gen::natural&lt;T&gt;(max)</code>","text":"<p>Generates positive integers in the range [1, max] (inclusive).</p> <p>Parameters:</p> <ul> <li><code>max</code> (T): Maximum value (inclusive, must be at least 1)</li> </ul> <p>Returns: <code>Generator&lt;T&gt;</code></p> <p>Examples: <pre><code>// Generate natural numbers from 1 to 1000\nauto positiveIntGen = gen::natural&lt;int&gt;(1000);\n\n// Different integer types\nauto uint16Gen = gen::natural&lt;uint16_t&gt;(65535);\n\n// Usage in forAll\nforAll([](int positive) {\n    // Property test with positive integers\n}, gen::natural&lt;int&gt;(1000));\n</code></pre></p> <p>See also: Basic Type Generators for integer type generators, gen::nonNegative(max) for non-negative integers."},{"location":"Generators/#gennonnegativetmax","title":"<code>gen::nonNegative&lt;T&gt;(max)</code>","text":"<p>Generates non-negative integers in the range [0, max] (inclusive).</p> <p>Parameters:</p> <ul> <li><code>max</code> (T): Maximum value (inclusive, must be non-negative)</li> </ul> <p>Returns: <code>Generator&lt;T&gt;</code></p> <p>Examples: <pre><code>// Generate non-negative integers from 0 to 500\nauto nonNegIntGen = gen::nonNegative&lt;int&gt;(500);\n\n// Usage in forAll\nforAll([](int nonNeg) {\n    // Property test with non-negative integers\n}, gen::nonNegative&lt;int&gt;(500));\n</code></pre></p> <p>See also: Basic Type Generators for integer type generators, gen::natural(max) for positive integers."},{"location":"Generators/#string-generators","title":"String Generators","text":"Alias Arbitrary Description <code>gen::string</code> <code>Arbi&lt;std::string&gt;</code> ASCII strings <code>gen::utf8string</code> <code>Arbi&lt;UTF8String&gt;</code> UTF-8 strings <code>gen::utf16bestring</code>, <code>gen::utf16lestring</code> <code>Arbi&lt;UTF16BEString&gt;</code>, <code>Arbi&lt;UTF16LEString&gt;</code> UTF-16 strings (big-endian, little-endian) <code>gen::cesu8string</code> <code>Arbi&lt;CESU8String&gt;</code> CESU-8 strings"},{"location":"Generators/#genstring","title":"<code>gen::string</code>","text":"<p>Generates ASCII strings. Defaults to printable ASCII characters (0x01-0x7f).</p> <p>Parameters:</p> <ul> <li><code>charGen</code> (optional): Generator for characters. If not provided, uses printable ASCII.</li> </ul> <p>Returns: <code>Generator&lt;std::string&gt;</code></p> <p>Examples: <pre><code>// Generate ASCII strings with default character set\nauto asciiStringGen = gen::string();\n\n// Custom string with specific character ranges\nauto uppercaseGen = gen::string(gen::interval&lt;char&gt;('A', 'Z'));\nauto digitGen = gen::string(gen::interval&lt;char&gt;('0', '9'));\n\n// Named parameters (C++20 designated initializers)\nauto strGen = gen::string({.minSize = 5, .maxSize = 20});\nauto strGen2 = gen::string({.elemGen = gen::interval&lt;char&gt;('A', 'Z'), .minSize = 3, .maxSize = 10});\n\n// Usage in forAll\nforAll([](std::string name) {\n    // Property test with strings\n}, gen::string());\n</code></pre></p> <p>See also: Utility Numeric Range Generators for <code>gen::interval</code>, Combinators for combining character generators, Arbitrary for configuration options.</p>"},{"location":"Generators/#genutf8string","title":"<code>gen::utf8string</code>","text":"<p>Generates UTF-8 strings. Defaults to all UTF-8 characters.<sup>1</sup></p> <p>Parameters:</p> <ul> <li><code>charGen</code> (optional): Generator for Unicode code points. If not provided, uses all UTF-8 characters.</li> </ul> <p>Returns: <code>Generator&lt;UTF8String&gt;</code></p> <p>Examples: <pre><code>// Generate UTF-8 strings with default character set\nauto utf8StringGen = gen::utf8string();\n\n// Custom UTF-8 string with specific character ranges\nauto alphanumericGen = gen::utf8string(gen::unionOf&lt;uint32_t&gt;(\n    gen::interval&lt;uint32_t&gt;('A', 'Z'),\n    gen::interval&lt;uint32_t&gt;('a', 'z'),\n    gen::interval&lt;uint32_t&gt;('0', '9')\n));\n\n// Named parameters (C++20 designated initializers)\nauto utf8Gen = gen::utf8string({.minSize = 1, .maxSize = 50});\n\n// Usage in forAll\nforAll([](UTF8String text) {\n    // text behaves like std::string for byte-level APIs:\n    // const char* raw      = text.c_str();   // pass to C APIs\n    // auto        byteSize = text.size();    // buffer size in bytes\n    // auto        charCnt  = text.charsize(); // number of UTF-8 code units / characters\n\n    // Property test with UTF-8 strings\n}, gen::utf8string());\n</code></pre></p> <p>See also: Combinators for <code>gen::unionOf</code> and other combinators, Utility Numeric Range Generators for <code>gen::interval</code>, Arbitrary for configuration options.</p>"},{"location":"Generators/#utf-16-string-generators","title":"UTF-16 String Generators","text":"<p>Generate UTF-16 strings in big-endian or little-endian byte order: <code>gen::utf16bestring</code>, <code>gen::utf16lestring</code>.<sup>1</sup></p> <p>Parameters:</p> <ul> <li><code>charGen</code> (optional): Generator for Unicode code points. If not provided, uses default character set.</li> </ul> <p>Returns: <code>Generator&lt;UTF16BEString&gt;</code> or <code>Generator&lt;UTF16LEString&gt;</code></p> <p>Examples: <pre><code>// Generate UTF-16 big-endian strings\nauto utf16beStringGen = gen::utf16bestring();\n\n// Generate UTF-16 little-endian strings\nauto utf16leStringGen = gen::utf16lestring();\n\n// Usage in forAll\nforAll([](UTF16BEString beText, UTF16LEString leText) {\n    // Underlying storage is std::string; .charsize() reports UTF-16 code units:\n    // const char* rawBE   = beText.c_str();\n    // const char* rawLE   = leText.c_str();\n    // auto        beBytes = beText.size();\n    // auto        beChars = beText.charsize();\n\n    // Property test with UTF-16 strings\n}, gen::utf16bestring(), gen::utf16lestring());\n</code></pre></p> <p>See also: Arbitrary for configuration options, <code>gen::utf8string</code> for UTF-8 strings.</p>"},{"location":"Generators/#gencesu8string","title":"<code>gen::cesu8string</code>","text":"<p>Generates CESU-8 strings.<sup>1</sup></p> <p>Parameters:</p> <ul> <li><code>charGen</code> (optional): Generator for Unicode code points.</li> </ul> <p>Returns: <code>Generator&lt;CESU8String&gt;</code></p> <p>Examples: <pre><code>// Generate CESU-8 strings\nauto cesu8StringGen = gen::cesu8string();\n\n// Usage in forAll\nforAll([](CESU8String text) {\n    // Access raw bytes and logical length:\n    // const char* raw      = text.data();\n    // auto        byteSize = text.size();\n    // auto        charCnt  = text.charsize();\n\n    // Property test with CESU-8 strings\n}, gen::cesu8string());\n</code></pre></p> <p>See also: Arbitrary for configuration options.</p>"},{"location":"Generators/#container-generators","title":"Container Generators","text":"<p>Container generators often take size ranges and an element generator (uses default generator for the type if not given) as arguments.</p> Alias Arbitrary Description <code>gen::vector&lt;T&gt;</code> <code>Arbi&lt;std::vector&lt;T&gt;&gt;</code> Vectors <code>gen::list&lt;T&gt;</code> <code>Arbi&lt;std::list&lt;T&gt;&gt;</code> Lists <code>gen::set&lt;T&gt;</code> <code>Arbi&lt;std::set&lt;T&gt;&gt;</code> Sets <code>gen::map&lt;K,V&gt;</code> <code>Arbi&lt;std::map&lt;K,V&gt;&gt;</code> Maps <code>gen::optional&lt;T&gt;</code> <code>Arbi&lt;std::optional&lt;T&gt;&gt;</code> Optional values <code>gen::shared_ptr&lt;T&gt;</code> <code>Arbi&lt;std::shared_ptr&lt;T&gt;&gt;</code> Shared pointers"},{"location":"Generators/#genvectort","title":"<code>gen::vector&lt;T&gt;</code>","text":"<p>Generates random vectors with elements of type <code>T</code>.</p> <p>Parameters:</p> <ul> <li><code>elementGen</code> (optional): Generator for vector elements. If not provided, uses default generator for type <code>T</code>.</li> <li><code>minSize</code>, <code>maxSize</code> (optional): Size constraints for the vector.</li> </ul> <p>Returns: <code>Generator&lt;std::vector&lt;T&gt;&gt;</code></p> <p>Examples: <pre><code>// Basic vector generator\nauto intVectorGen = gen::vector&lt;int&gt;();\n\n// Vector with custom element generator\nauto smallIntVectorGen = gen::vector&lt;int&gt;(gen::interval&lt;int&gt;(1, 100));\n\n// Vector with size constraints\nauto fixedSizeVectorGen = gen::vector&lt;int&gt;();\nfixedSizeVectorGen.setSize(5); // Always generates vectors of size 5\n\nauto boundedVectorGen = gen::vector&lt;int&gt;();\nboundedVectorGen.setMinSize(1);\nboundedVectorGen.setMaxSize(10); // Generates vectors of size 1-10\n\n// Size range in constructor\nauto vectorGen1 = gen::vector&lt;int&gt;(5, 5); // Fixed size 5\nauto vectorGen2 = gen::vector&lt;int&gt;(gen::interval(1,10), 5, 5); // element generator + size range\n\n// Named parameters (C++20 designated initializers)\nauto vectorGen3 = gen::vector&lt;int&gt;({.minSize = 5, .maxSize = 20});\nauto vectorGen4 = gen::vector&lt;int&gt;({.elemGen = gen::interval&lt;int&gt;(1, 100), .minSize = 5, .maxSize = 20});\n\n// Usage in forAll\nforAll([](std::vector&lt;int&gt; numbers) {\n    // Property test with vectors\n}, gen::vector&lt;int&gt;());\n</code></pre></p> <p>See also: Arbitrary for configuration options, Utility Numeric Range Generators for <code>gen::interval</code>.</p>"},{"location":"Generators/#genlistt","title":"<code>gen::list&lt;T&gt;</code>","text":"<p>Generates random lists with elements of type <code>T</code>.</p> <p>Parameters:</p> <ul> <li><code>elementGen</code> (optional): Generator for list elements. If not provided, uses default generator for type <code>T</code>.</li> <li><code>minSize</code>, <code>maxSize</code> (optional): Size constraints for the list.</li> </ul> <p>Returns: <code>Generator&lt;std::list&lt;T&gt;&gt;</code></p> <p>Examples: <pre><code>// Basic list generator\nauto stringListGen = gen::list&lt;std::string&gt;();\n\n// List with custom element generator\nauto uppercaseStringListGen = gen::list&lt;std::string&gt;(gen::string(gen::interval&lt;char&gt;('A', 'Z')));\n\n// Named parameters (C++20 designated initializers)\nauto listGen = gen::list&lt;int&gt;({.elemGen = gen::interval&lt;int&gt;(0, 9), .minSize = 1, .maxSize = 10});\n\n// Usage in forAll\nforAll([](std::list&lt;std::string&gt; items) {\n    // Property test with lists\n}, gen::list&lt;std::string&gt;());\n</code></pre></p> <p>See also: Arbitrary for configuration options, String Generators for string element generators.</p>"},{"location":"Generators/#gensett","title":"<code>gen::set&lt;T&gt;</code>","text":"<p>Generates random sets with elements of type <code>T</code>.</p> <p>Parameters:</p> <ul> <li><code>elementGen</code> (optional): Generator for set elements. If not provided, uses default generator for type <code>T</code>.</li> <li><code>minSize</code>, <code>maxSize</code> (optional): Size constraints for the set.</li> </ul> <p>Returns: <code>Generator&lt;std::set&lt;T&gt;&gt;</code></p> <p>Examples: <pre><code>// Basic set generator\nauto intSetGen = gen::set&lt;int&gt;();\n\n// Named parameters (C++20 designated initializers)\nauto setGen = gen::set&lt;int&gt;({.minSize = 3, .maxSize = 15});\n\n// Usage in forAll\nforAll([](std::set&lt;int&gt; uniqueNumbers) {\n    // Property test with sets\n}, gen::set&lt;int&gt;());\n</code></pre></p> <p>See also: Arbitrary for configuration options.</p>"},{"location":"Generators/#genmapkv","title":"<code>gen::map&lt;K,V&gt;</code>","text":"<p>Generates random maps with keys of type <code>K</code> and values of type <code>V</code>.</p> <p>Parameters:</p> <ul> <li><code>keyGen</code> (optional): Generator for map keys. If not provided, uses default generator for type <code>K</code>.</li> <li><code>valueGen</code> (optional): Generator for map values. If not provided, uses default generator for type <code>V</code>.</li> <li><code>minSize</code>, <code>maxSize</code> (optional): Size constraints for the map.</li> </ul> <p>Returns: <code>Generator&lt;std::map&lt;K,V&gt;&gt;</code></p> <p>Examples: <pre><code>// Basic map generator\nauto stringIntMapGen = gen::map&lt;std::string, int&gt;();\n\n// Map with custom key and value generators\nauto customMapGen = gen::map&lt;std::string, int&gt;({.keyGen = gen::string(gen::interval&lt;char&gt;('a', 'z')), .valueGen = gen::interval&lt;int&gt;(0, 100)});\n\n// Named parameters (C++20 designated initializers)\nauto mapGen = gen::map&lt;int,int&gt;({.minSize = 5, .maxSize = 20});\nauto mapGen2 = gen::map&lt;int,int&gt;({.keyGen = gen::int32(), .valueGen = gen::int32(), .minSize = 5, .maxSize = 20});\n\n// Usage in forAll\nforAll([](std::map&lt;std::string, int&gt; data) {\n    // Property test with maps\n}, gen::map&lt;std::string, int&gt;());\n</code></pre></p> <p>See also: Arbitrary for configuration options, String Generators for string key generators, Utility Numeric Range Generators for integer value generators.</p>"},{"location":"Generators/#genoptionalt","title":"<code>gen::optional&lt;T&gt;</code>","text":"<p>Generates random optional values of type <code>T</code>.</p> <p>Parameters:</p> <ul> <li><code>elementGen</code> (optional): Generator for the contained value. If not provided, uses default generator for type <code>T</code>.</li> </ul> <p>Returns: <code>Generator&lt;std::optional&lt;T&gt;&gt;</code></p> <p>Examples: <pre><code>// Basic optional generator\nauto optionalIntGen = gen::optional&lt;int&gt;();\n\n// Usage in forAll\nforAll([](std::optional&lt;int&gt; maybeValue) {\n    // Property test with optionals\n}, gen::optional&lt;int&gt;());\n</code></pre></p> <p>See also: Arbitrary for configuration options.</p>"},{"location":"Generators/#genshared_ptrt","title":"<code>gen::shared_ptr&lt;T&gt;</code>","text":"<p>Generates random shared pointers to values of type <code>T</code>.</p> <p>Parameters:</p> <ul> <li><code>elementGen</code> (optional): Generator for the pointed-to value. If not provided, uses default generator for type <code>T</code>.</li> </ul> <p>Returns: <code>Generator&lt;std::shared_ptr&lt;T&gt;&gt;</code></p> <p>Examples: <pre><code>// Basic shared_ptr generator\nauto sharedPtrIntGen = gen::shared_ptr&lt;int&gt;();\n\n// Usage in forAll\nforAll([](std::shared_ptr&lt;int&gt; ptr) {\n    // Property test with shared pointers\n}, gen::shared_ptr&lt;int&gt;());\n</code></pre></p> <p>See also: Arbitrary for configuration options.</p>"},{"location":"Generators/#tuple-and-pair-generators","title":"Tuple and Pair Generators","text":"<p><code>gen::pair</code> and <code>gen::tuple</code> generators take optional element generators as arguments. The generators are optional only if the types have <code>Arbitrary</code> defined.</p> Alias Arbitrary Description <code>gen::pair&lt;T1,T2&gt;</code> <code>Arbi&lt;std::pair&lt;T1,T2&gt;&gt;</code> Pairs <code>gen::tuple&lt;Ts...&gt;</code> <code>Arbi&lt;std::tuple&lt;Ts...&gt;&gt;</code> Tuples <code>gen::pair</code> Pairs (type params inferred) <code>gen::tuple</code> Tuples (type params inferred)"},{"location":"Generators/#genpairt1t2","title":"<code>gen::pair&lt;T1,T2&gt;</code>","text":"<p>Generates random pairs with elements of types <code>T1</code> and <code>T2</code>.</p> <p>Parameters:</p> <ul> <li><code>gen1</code>, <code>gen2</code> (optional): Generators for the first and second elements. If not provided, uses default generators for types <code>T1</code> and <code>T2</code>.</li> </ul> <p>Returns: <code>Generator&lt;std::pair&lt;T1,T2&gt;&gt;</code></p> <p>Examples: <pre><code>// Basic pair generator\nauto intStringPairGen = gen::pair&lt;int, std::string&gt;();\n\n// Pair with custom element generators\nauto smallIntUppercaseStringPairGen = gen::pair(\n    gen::interval&lt;int&gt;(1, 100),\n    gen::string(gen::interval&lt;char&gt;('A', 'Z'))\n);\n\n// Type-inferred pair (convenient wrapper)\nauto pairGen = gen::pair(\n    gen::interval&lt;int&gt;(1, 100),\n    gen::string(gen::interval&lt;char&gt;('A', 'Z'))\n); // generator for pair&lt;int, string&gt;\n\n// Usage in forAll\nforAll([](std::pair&lt;int, std::string&gt; data) {\n    // Property test with pairs\n}, gen::pair&lt;int, std::string&gt;());\n</code></pre></p> <p>See also: Utility Numeric Range Generators for <code>gen::interval</code>, String Generators for string generators, Combinators for <code>gen::chain</code> and dependent pair generation.</p>"},{"location":"Generators/#gentuplets","title":"<code>gen::tuple&lt;Ts...&gt;</code>","text":"<p>Generates random tuples with elements of types <code>Ts...</code>.</p> <p>Parameters:</p> <ul> <li><code>...gens</code> (optional): Generators for tuple elements. If not provided, uses default generators for the element types.</li> </ul> <p>Returns: <code>Generator&lt;std::tuple&lt;Ts...&gt;&gt;</code></p> <p>Examples: <pre><code>// Basic tuple generator\nauto intBoolStringTupleGen = gen::tuple&lt;int, bool, std::string&gt;();\n\n// Tuple with custom element generators\nauto customTupleGen = gen::tuple(\n    gen::interval&lt;int&gt;(-50, 50),\n    gen::boolean(),\n    gen::string(gen::interval&lt;char&gt;('a', 'z'))\n);\n\n// Type-inferred tuple (convenient wrapper)\nauto tupleGen = gen::tuple(\n    gen::interval&lt;int&gt;(-50, 50),\n    gen::boolean(),\n    gen::string(gen::interval&lt;char&gt;('a', 'z'))\n); // generator for tuple&lt;int, bool, string&gt;\n\n// Usage in forAll\nforAll([](std::tuple&lt;int, bool, std::string&gt; info) {\n    // Property test with tuples\n}, gen::tuple&lt;int, bool, std::string&gt;());\n</code></pre></p> <p>See also: Utility Numeric Range Generators for <code>gen::interval</code>, Basic Type Generators for element generators, Combinators for <code>gen::chain</code> and dependent tuple generation.</p>"},{"location":"Generators/#interval-generators","title":"Interval Generators","text":"<p>Interval generators are basically shorthand equivalents for combining multiple numeric ranges (e.g. <code>gen::interval</code>) with a <code>gen::oneOf</code> (<code>gen::unionOf</code>) combinator.</p> Alias Description <code>gen::intervals({Interval(min1,max1), ...})</code> Multiple intervals for signed integers <code>gen::uintervals({UInterval(min1,max1), ...})</code> Multiple intervals for unsigned integers <p>Examples: <pre><code>// Multiple interval generators\nauto multiRangeIntGen = gen::intervals({\n    gen::Interval(-100, -1),    // Negative numbers\n    gen::Interval(1, 100)       // Positive numbers\n});\n\nauto multiRangeUintGen = gen::uintervals({\n    gen::UInterval(0, 9),       // Single digits\n    gen::UInterval(100, 999)    // Three digits\n});\n\n// Usage in forAll\nforAll([](int64_t multiRange) {\n    // Property test with multi-interval integers\n}, gen::intervals({gen::Interval(-100, -1), gen::Interval(1, 100)}));\n</code></pre></p> <p>See also: Combinators for <code>gen::oneOf</code> and <code>gen::unionOf</code>, Utility Numeric Range Generators for single interval generators, Basic Type Generators for integer type generators.</p>"},{"location":"Generators/#floating-point-generators","title":"Floating Point Generators","text":"<p>Floating point generators (<code>gen::float32</code> and <code>gen::float64</code>) support configurable probabilities for special IEEE 754 values: NaN, positive infinity, and negative infinity.</p>"},{"location":"Generators/#interface","title":"Interface","text":"<p>Constructor signatures: <pre><code>gen::float32(double nanProb = 0.0, double posInfProb = 0.0, double negInfProb = 0.0)\ngen::float64(double nanProb = 0.0, double posInfProb = 0.0, double negInfProb = 0.0)\n\n// Equivalent to:\nArbi&lt;float&gt;(double nanProb = 0.0, double posInfProb = 0.0, double negInfProb = 0.0)\nArbi&lt;double&gt;(double nanProb = 0.0, double posInfProb = 0.0, double negInfProb = 0.0)\n\n// Named parameters (C++20 designated initializers) \u2014 all fields optional:\nArbi&lt;float&gt;({.nanProb = 0.1, .posInfProb = 0.05, .negInfProb = 0.02})\nArbi&lt;double&gt;({.nanProb = 0.1})\ngen::float32({.nanProb = 0.1, .posInfProb = 0.05})\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>nanProb</code> (default: <code>0.0</code>): Probability of generating NaN, must be in range [0.0, 1.0]</li> <li><code>posInfProb</code> (default: <code>0.0</code>): Probability of generating positive infinity, must be in range [0.0, 1.0]</li> <li><code>negInfProb</code> (default: <code>0.0</code>): Probability of generating negative infinity, must be in range [0.0, 1.0]</li> </ul> <p>Constraints:</p> <ul> <li>Each probability must be between 0.0 and 1.0 (inclusive)</li> <li>The sum of all probabilities must be \u2264 1.0</li> <li>The remaining probability (1.0 - sum) is used for generating finite values</li> </ul> <p>The constructor validates these requirements and throws <code>runtime_error</code> if they are not met.</p>"},{"location":"Generators/#default-behavior","title":"Default Behavior","text":"<p>By default, floating point generators produce only finite values (no NaN or infinity):</p> <pre><code>// Default: generates only finite values\nauto floatGen = gen::float32();\nauto doubleGen = gen::float64();\n\nforAll([](float f, double d) {\n    PROP_ASSERT(isfinite(f));\n    PROP_ASSERT(isfinite(d));\n}, gen::float32(), gen::float64());\n</code></pre>"},{"location":"Generators/#special-value-probabilities","title":"Special Value Probabilities","text":"<p>You can configure the probability of generating special values using constructor parameters:</p> <pre><code>// Generate 10% NaN, 90% finite\nauto floatWithNaN = gen::float32(0.1, 0.0, 0.0);\n\n// Generate 5% +inf, 5% -inf, 90% finite\nauto floatWithInf = gen::float32(0.0, 0.05, 0.05);\n\n// Generate 5% each special value, 85% finite\nauto floatWithAll = gen::float32(0.05, 0.05, 0.05);\n\n// When sum = 1.0, no finite values are generated\nauto onlySpecial = gen::float32(0.5, 0.3, 0.2); // 50% NaN, 30% +inf, 20% -inf\n\n// Same API for double\nauto doubleWithNaN = gen::float64(0.1, 0.0, 0.0);\n\n// Named parameters (C++20) \u2014 clearer when specifying only some options\nauto floatWithNaN = Arbi&lt;float&gt;({.nanProb = 0.1});\nauto floatWithAll = Arbi&lt;float&gt;({.nanProb = 0.05, .posInfProb = 0.05, .negInfProb = 0.05});\n\n// Usage in forAll\nforAll([](float f) {\n    PROP_STAT(std::isfinite(f));\n    PROP_STAT(std::isinf(f));\n    PROP_STAT(std::isnan(f));\n    PROP_STAT(f &gt; 0);\n    PROP_STAT(f &lt; 0);\n}, gen::float64(0.05, 0.05, 0.05));\n</code></pre> <p>See also: Property API Reference for <code>PROP_STAT</code> usage, Basic Type Generators for other numeric generators, Arbitrary for floating-point generator configuration.</p>"},{"location":"Generators/#access-to-an-arbitrary","title":"Access to an Arbitrary","text":"<p>While arbitraries (default generator) for type <code>T</code> can be accessed using <code>proptest::Arbitrary&lt;T&gt;</code>, a proxy in <code>gen</code> namespace is also provided. You may find it useful if type should be parameterized:</p> Function Description <code>gen::arbitrary&lt;T&gt;(...)</code> alias to <code>proptest::Arbitrary&lt;T&gt;</code> <p>See also: Arbitrary for details on arbitraries and how to define custom ones.</p>"},{"location":"Generators/#combinator-functions","title":"Combinator Functions","text":"<p>The second part of <code>gen</code> namespace contains all the combinators provided by <code>cppproptest</code>. Combinators transform or combine existing generators to create new, more complex ones.</p> Function Description <code>gen::just&lt;T&gt;(value)</code> Constant value <code>gen::elementOf&lt;T&gt;(vals...)</code> Random selection from values <code>gen::oneOf&lt;T&gt;(gens...)</code> Union of generators <code>gen::unionOf&lt;T&gt;(gens...)</code> Alias for <code>gen::oneOf</code> <code>gen::construct&lt;Class,Args...&gt;(gens...)</code> Object construction <code>gen::transform&lt;T,U&gt;(gen, func)</code> Value transformation <code>gen::derive&lt;T,U&gt;(gen, genGen)</code> Value derivation (flat-map) <code>gen::filter&lt;T&gt;(gen, predicate)</code> Value filtering <code>gen::suchThat&lt;T&gt;(gen, predicate)</code> Alias for filter <code>gen::dependency&lt;T,U&gt;(genT, genUGen)</code> Dependency between values <code>gen::chain&lt;T&gt;(genT, genGen)</code> Chain of generators <code>gen::aggregate&lt;T&gt;(genT, aggregator)</code> Aggregation of values <code>gen::accumulate&lt;T&gt;(genT, accumulator, min, max)</code> Accumulation of values <code>gen::lazy&lt;T&gt;(func)</code> Lazy evaluation <code>gen::reference&lt;T&gt;(ref)</code> Reference wrapper <p>Examples: <pre><code>// Constant value generator\nauto constantGen = gen::just&lt;int&gt;(42);\n\n// Random selection from values\nauto choiceGen = gen::elementOf&lt;int&gt;(1, 2, 3, 5, 7, 11, 13);\n\n// Union of generators (see [Combinators](Combinators.md) for gen::oneOf, [Utility Numeric Range Generators](#utility-numeric-range-generators) for gen::interval)\nauto mixedIntGen = gen::oneOf&lt;int&gt;(\n    gen::interval&lt;int&gt;(1, 10),\n    gen::interval&lt;int&gt;(100, 110),\n    gen::interval&lt;int&gt;(1000, 1010)\n);\n\n// Object construction (see [Combinators](Combinators.md) for gen::construct, [Utility Numeric Range Generators](#utility-numeric-range-generators) for gen::interval)\nstruct Point {\n    Point(int x, int y) : x(x), y(y) {}\n    int x, y;\n};\nauto pointGen = gen::construct&lt;Point, int, int&gt;(\n    gen::interval&lt;int&gt;(-100, 100),\n    gen::interval&lt;int&gt;(-100, 100)\n);\n\n// Value transformation (see [Combinators](Combinators.md) for gen::transform, [String Generators](#string-generators) for gen::string)\nauto stringLengthGen = gen::transform&lt;std::string, size_t&gt;(\n    gen::string(),\n    [](const std::string&amp; s) { return s.length(); }\n);\n\n// Value filtering (see [Combinators](Combinators.md) for gen::filter, [Basic Type Generators](#basic-type-generators) for gen::int32)\nauto evenIntGen = gen::filter&lt;int&gt;(\n    gen::int32(),\n    [](int n) { return n % 2 == 0; }\n);\n\n// Dependency between values (see [Combinators](Combinators.md) for gen::dependency, [Utility Numeric Range Generators](#utility-numeric-range-generators) for gen::interval, [String Generators](#string-generators) for gen::string)\nauto dependentGen = gen::dependency&lt;int, std::string&gt;(\n    gen::interval&lt;int&gt;(1, 10),\n    [](int size) { return gen::string().setSize(size); }\n);\n\n// Usage in forAll\nforAll([](int choice, Point p, size_t length, int even) {\n    // Property test with combinator-generated values\n}, gen::elementOf&lt;int&gt;(1, 2, 3),\n   gen::construct&lt;Point, int, int&gt;(gen::interval&lt;int&gt;(-100, 100), gen::interval&lt;int&gt;(-100, 100)),\n   gen::transform&lt;std::string, size_t&gt;(gen::string(), [](const std::string&amp; s) { return s.length(); }),\n   gen::filter&lt;int&gt;(gen::int32(), [](int n) { return n % 2 == 0; }));\n</code></pre></p> <p>See also: Combinators for comprehensive documentation on all combinators, including detailed examples and use cases.</p>"},{"location":"Generators/#utility-functions-for-oneofunionof-and-elementof","title":"Utility Functions for <code>oneOf</code>(<code>unionOf</code>) and <code>elementOf</code>","text":"<p>There are utility functions for providing probabilities for each value or generator to be chosen for <code>gen::oneOf</code> or <code>gen::elementOf</code>.</p> Alias Description <code>gen::weighted&lt;T&gt;(gen, weight)</code> Weighted generator decorator <code>gen::weightedVal&lt;T&gt;(value, weight)</code> Weighted value decorator <p>See also: Combinators for details on weighted selection.</p>"},{"location":"Generators/#examples","title":"Examples","text":""},{"location":"Generators/#basic-generators","title":"Basic Generators","text":"<pre><code>// Basic types (see [Basic Type Generators](#basic-type-generators))\nauto boolGen = gen::boolean();\nauto intGen = gen::int32();\nauto stringGen = gen::string(); // see [String Generators](#string-generators)\n\n// Floating point - default (finite only) (see [Floating Point Generators](#floating-point-generators))\nauto floatGen = gen::float32();\nauto doubleGen = gen::float64();\n\n// Floating point with special values (see [Floating Point Generators](#floating-point-generators))\nauto floatWithNaN = gen::float32(0.1, 0.0, 0.0); // 10% NaN, 90% finite\nauto doubleWithInf = gen::float64(0.0, 0.05, 0.05); // 5% +inf, 5% -inf, 90% finite\n\n// Numeric ranges - these are function calls, not type aliases (see [Utility Numeric Range Generators](#utility-numeric-range-generators))\nauto smallIntGen = gen::interval(1, 100);\nauto positiveIntGen = gen::natural(1000);\nauto nonNegIntGen = gen::nonNegative(500);\n</code></pre>"},{"location":"Generators/#container-generators_1","title":"Container Generators","text":"<pre><code>// Simple containers (see [Container Generators](#container-generators))\nauto intVectorGen = gen::vector&lt;int&gt;();\nauto stringListGen = gen::list&lt;std::string&gt;();\nauto intSetGen = gen::set&lt;int&gt;();\nauto stringIntMapGen = gen::map&lt;std::string, int&gt;();\n\n// Nested containers\nauto vectorOfMapsGen = gen::vector&lt;gen::map&lt;std::string, int&gt;&gt;();\nauto mapOfVectorsGen = gen::map&lt;std::string, gen::vector&lt;int&gt;&gt;();\n</code></pre>"},{"location":"Generators/#string-generators-with-custom-elements","title":"String Generators with Custom Elements","text":"<pre><code>// Custom character ranges (see [String Generators](#string-generators), [Utility Numeric Range Generators](#utility-numeric-range-generators) for gen::interval, [Combinators](Combinators.md) for gen::unionOf)\nauto uppercaseGen = gen::string(gen::interval&lt;char&gt;('A', 'Z'));\nauto digitGen = gen::string(gen::interval&lt;char&gt;('0', '9'));\nauto alphanumericGen = gen::string(gen::unionOf&lt;char&gt;(\n    gen::interval&lt;char&gt;('A', 'Z'),\n    gen::interval&lt;char&gt;('a', 'z'),\n    gen::interval&lt;char&gt;('0', '9')\n));\n</code></pre> <p>See also: Generator Examples for more comprehensive real-world examples.</p>"},{"location":"Generators/#building-custom-generators","title":"Building Custom Generators","text":"<p>You can build your own generator for type <code>T</code> by manually defining the conforming generator type <code>GenFunction&lt;T&gt;</code>. You can refer to Building Custom Generators from Scratch for more information.</p> <p>While you can build a custom generator from scratch, it's usually not recommended as there is a better option - using a generator combinator. Generator combinators are toolkit for building new generators based on existing ones. They can also be chained to create another generator out of themselves.</p> <p>See also: Combinators for comprehensive guide on using combinators, Custom Generator for building generators from scratch, Generator Examples for practical examples.</p>"},{"location":"Generators/#related-topics","title":"Related Topics","text":"<ul> <li>Arbitrary - Default generators for types</li> <li>Combinators - Transform and combine generators</li> <li>Custom Generator - Building generators from scratch</li> <li>Generator Examples - Real-world generator usage</li> <li>Gen Namespace - Organization of the <code>gen</code> namespace</li> <li>Walkthrough - Step-by-step guide to using generators</li> <li>Property API Reference - Using generators with <code>forAll()</code> and <code>property()</code></li> <li>Shrinking - How generated values are simplified when tests fail</li> </ul> <p>This design differs from <code>std::u8string</code> / <code>std::u16string</code>, but is used in <code>cppproptest</code> to keep generator and shrinking support built on top of <code>std::string</code> storage.</p> <ol> <li> <p>Encoding-aware string types <code>UTF8String</code>, <code>UTF16BEString</code>, <code>UTF16LEString</code>, and <code>CESU8String</code> are implemented as classes derived from <code>std::string</code>. This lets you use standard string APIs such as <code>.c_str()</code> / <code>.data()</code> to access the underlying bytes and <code>.size()</code> to get the buffer length in bytes, while <code>.charsize()</code> reports the logical character/code-unit count. For example: <pre><code>UTF8String s = UTF8String(\"caf\u00e9\");\nauto bytes = s.size();     // buffer size in bytes\nauto chars = s.charsize(); // number of Unicode code units\nconst char* raw = s.c_str(); // pass to C APIs\n</code></pre> \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"GettingStarted/","title":"Getting Started with <code>cppproptest</code>","text":"<p><code>cppproptest</code> can be built and used with CMake. You can examine the requirements with:</p> <pre><code># at cppproptest root directory\n$ cmake . -BBUILD\n$ cd BUILD &amp;&amp; make &amp;&amp; ./test_proptest\n</code></pre> <p>You can edit your project's CMakeLists.txt to include the library <code>proptest</code>:</p> <pre><code>ADD_SUBDIRECTORY(&lt;path_to_cppproptest_root&gt;)\n</code></pre> <p>And then add the shared library <code>proptest</code> to <code>TARGET_LINK_LIBRARIES</code> section.</p> <pre><code>TARGET_LINK_LIBRARIES( ...\n    ...\n    proptest\n    ...\n)\n</code></pre> <p>Here's an example using Googletest:</p> <pre><code>// ...\n#include \"proptest/proptest.hpp\"\n\nusing namespace proptest;\n\nTEST(AudioCodec, EncoderDecoder)\n{\n    // ASSERT_FOR_ALL() is shorthand for ASSERT_TRUE(forAll(...))\n    ASSERT_FOR_ALL([](SoundData soundData) {\n        auto encoded = MyAudioCodec::encode(soundData);\n        auto decoded = MyAudioCodec::decode(encoded);\n        PROP_ASSERT_EQ(decoded, soundData);\n    });\n}\n</code></pre> <p>Note that <code>ASSERT_FOR_ALL</code> is a simple macro wrapping an <code>ASSERT_TRUE</code> google test macro around the <code>proptest::forAll</code> function. Similarly, <code>EXPECT_MATRIX</code> and <code>ASSERT_MATRIX</code> wrap <code>proptest::matrix()</code> for Cartesian product tests. You can find more information in Property API Reference - Google Test Integration Macros.</p> <p>Next Steps: - Step-by-Step Walkthrough - Learn how to create property tests step-by-step - Property API Reference - Complete API reference for property testing</p>"},{"location":"Mocking/","title":"Mocking","text":""},{"location":"Mocking/#generating-mocks","title":"Generating Mocks","text":"<p>This page is work in progress</p>"},{"location":"Mocking/#todo","title":"TODO","text":""},{"location":"Printing/","title":"Printing Facilities for Displaying Custom Types","text":"<p>It's sometimes recommended to have a printer defined for a type. It would ensure values of a type to be correctly printed. <code>cppproptest</code> fully defines printers for built-in types.</p> <pre><code>// a std::tuple&lt;std::tuple&lt;int, std::tuple&lt;int&gt;&gt;&gt; type is printed:\nshrinking found simpler failing arg 0: { { -10, { -1002144 } } }\n</code></pre> <p>For a new type you'd like to use with <code>cppproptest</code>, you can define a printer for that type. As you can see in above example, complex recursive structures such as tuple of tuples can be printed if you have correctly defined it. If there is no printer is defined for a type yet, '???' would be printed instead, as there is no correct way known to <code>cppproptest</code> how to printing that type .</p> <pre><code>// Car type that does not yet have a printing method, so it's printed as '???':\nshrinking found simpler failing arg 0: ???\n</code></pre>"},{"location":"Printing/#defining-a-printer-for-a-type","title":"Defining a printer for a type","text":"<p>Defining a printer for type <code>T</code> can be achieved by defining the struct specialization <code>proptest::util::ShowDefault&lt;T&gt;</code>:</p> <pre><code>namespace proptest {\nnamespace util {\n\n// printer for Car class\ntemplate &lt;&gt;\nstruct ShowDefault&lt;Car&gt;\n{\n    static std::ostream&amp; show(std::ostream&amp; os, const Car&amp; car)\n    {\n        os &lt;&lt; \"Car(\" &lt;&lt; car.name &lt;&lt; \", \" &lt;&lt; car.year &lt;&lt; \")\";\n        return os;\n    }\n};\n\n} // namespace util\n} // namespace proptest\n</code></pre> <p>This will be called whenever <code>T</code> is being printed by <code>cppproptest</code>:</p> <pre><code>// Car type now has a printer defined\nshrinking found simpler failing arg 0: Car(Ferari, 2020)\n</code></pre>"},{"location":"Printing/#defining-a-printer-for-a-templated-type","title":"Defining a printer for a templated type","text":"<p>You can also define a printer for a templated type as following:</p> <pre><code>namespace proptest {\nnamespace util {\n\n// printer for CarLike&lt;T&gt;\ntemplate &lt;typename T&gt;\nstruct ShowDefault&lt;CarLike&lt;T&gt;&gt;\n{\n    static std::ostream&amp; show(std::ostream&amp; os, const CarLike&lt;T&gt;&amp;)\n    {\n        os &lt;&lt; \"CarLike()\";\n        return os;\n    }\n};\n\n} // namespace util\n} // namespace proptest\n</code></pre> <p>This will print a <code>CarLike</code> as:</p> <pre><code>shrinking found simpler failing arg 0: CarLike()\n</code></pre>"},{"location":"Printing/#utilizing-other-printers","title":"Utilizing other printers","text":"<p>If your printer fneeds to print another type <code>T</code>, you can use an already defined (either built-in or custom one) printer for <code>T</code> by calling <code>proptest::util::Show&lt;T&gt;(T&amp;)</code>, as following:</p> <pre><code>namespace proptest {\nnamespace util {\n\ntemplate &lt;typename T&gt;\nstruct ShowDefault&lt;CarLike&lt;T&gt;&gt;\n{\n    static std::ostream&amp; show(std::ostream&amp; os, const CarLike&lt;T&gt;&amp; carLike)\n    {\n        // utilize printer for type T ('CarLike(???)' will be printed if there is no printer defined for T)\n        os &lt;&lt; \"CarLike(\" &lt;&lt; Show&lt;T&gt;(carLike.t) &lt;&lt; \")\";\n        return os;\n    }\n};\n\n} // namespace util\n} // namespace proptest\n</code></pre> <p>Now it will correctly prints a <code>CarLike&lt;Car&gt;</code>:</p> <pre><code>shrinking found simpler failing arg 0: CarLike(Car(Ferari, 2020))\n</code></pre>"},{"location":"PropertyAPI/","title":"Property API Reference","text":"<p>New to property-based testing? Start with the Walkthrough for a step-by-step guide to creating your first property test. This page provides the complete API reference.</p>"},{"location":"PropertyAPI/#overview","title":"Overview","text":"<p><code>cppproptest</code> provides a property-based testing framework where you define properties (invariants) that should hold for all inputs in a domain, rather than testing specific examples. The framework automatically generates random inputs and verifies your properties.</p> <p></p>"},{"location":"PropertyAPI/#quick-reference","title":"Quick Reference","text":""},{"location":"PropertyAPI/#functions","title":"Functions","text":"Function Description Returns <code>proptest::property(callable, ...generators)</code> Create a <code>Property</code> object from a callable <code>Property</code> <code>proptest::forAll(callable, ...)</code> Create and run a property immediately <code>Property</code> <code>proptest::matrix(callable, ...lists)</code> Create and run a matrix test immediately <code>Property</code>"},{"location":"PropertyAPI/#property-class-methods","title":"Property Class Methods","text":"Method Description Returns <code>.forAll(...generators)</code> Run property with random inputs <code>Property</code> <code>.example(...args)</code> Run property with specific inputs <code>Property</code> <code>.matrix(...lists)</code> Run property with Cartesian product of inputs <code>Property</code> <p>See Chaining for immutable chaining, failure propagation, short-circuiting, and config preservation.</p>"},{"location":"PropertyAPI/#configuration-methods","title":"Configuration Methods","text":"<p>All configuration methods return a reference to <code>Property</code>, allowing method chaining.</p> Method Description Parameters <code>.setSeed(seed)</code> Set random seed for reproducibility <code>uint64_t seed</code> <code>.setNumRuns(runs)</code> Set number of test runs <code>uint32_t runs</code> (default: 1000) <code>.setMaxDurationMs(duration)</code> Set maximum test duration in milliseconds <code>uint32_t durationMs</code> <code>.setOnStartup(callback)</code> Set callback called before each test run <code>Function&lt;void()&gt; callback</code> <code>.setOnCleanup(callback)</code> Set callback called after each test run <code>Function&lt;void()&gt; callback</code> <code>.setConfig(config)</code> Configure multiple options at once <code>ForAllConfig</code> (designated initializers)"},{"location":"PropertyAPI/#macros","title":"Macros","text":""},{"location":"PropertyAPI/#assertion-macros","title":"Assertion Macros","text":"Macro Type Description <code>PROP_ASSERT_EQ(A, B)</code> Fatal Assert equality <code>PROP_ASSERT_NE(A, B)</code> Fatal Assert not equal <code>PROP_ASSERT_LT(A, B)</code> Fatal Assert less than <code>PROP_ASSERT_LE(A, B)</code> Fatal Assert less than or equal <code>PROP_ASSERT_GT(A, B)</code> Fatal Assert greater than <code>PROP_ASSERT_GE(A, B)</code> Fatal Assert greater than or equal <code>PROP_EXPECT_EQ(A, B)</code> Non-fatal Expect equality (continues on failure) <code>PROP_EXPECT_NE(A, B)</code> Non-fatal Expect not equal <code>PROP_EXPECT_LT(A, B)</code> Non-fatal Expect less than <code>PROP_EXPECT_LE(A, B)</code> Non-fatal Expect less than or equal <code>PROP_EXPECT_GT(A, B)</code> Non-fatal Expect greater than <code>PROP_EXPECT_GE(A, B)</code> Non-fatal Expect greater than or equal"},{"location":"PropertyAPI/#statistics-and-tagging-macros","title":"Statistics and Tagging Macros","text":"Macro Description <code>PROP_STAT(expr)</code> Collect statistics about expression values <code>PROP_TAG(key, value)</code> Categorize test cases with custom labels <code>PROP_CLASSIFY(cond, key, value)</code> Conditionally tag test cases <code>PROP_STAT_ASSERT_GE(expr, bound)</code> Assert ratio of <code>expr</code> true \u2265 bound (0\u20131) <code>PROP_STAT_ASSERT_LE(expr, bound)</code> Assert ratio of <code>expr</code> true \u2264 bound (0\u20131) <code>PROP_STAT_ASSERT_IN_RANGE(expr, min, max)</code> Assert ratio of <code>expr</code> true in [min, max]"},{"location":"PropertyAPI/#test-control-macros","title":"Test Control Macros","text":"Macro Description <code>PROP_DISCARD()</code> Skip current test iteration (input doesn't meet preconditions) <code>PROP_SUCCESS()</code> Mark current test iteration as passed and skip remaining checks"},{"location":"PropertyAPI/#google-test-integration-macros","title":"Google Test Integration Macros","text":"Macro Description <code>EXPECT_FOR_ALL(...)</code> Run <code>forAll()</code> with <code>EXPECT_TRUE</code> (non-fatal) <code>ASSERT_FOR_ALL(...)</code> Run <code>forAll()</code> with <code>ASSERT_TRUE</code> (fatal) <code>EXPECT_MATRIX(...)</code> Run <code>matrix()</code> with <code>EXPECT_TRUE</code> (non-fatal) <code>ASSERT_MATRIX(...)</code> Run <code>matrix()</code> with <code>ASSERT_TRUE</code> (fatal)"},{"location":"PropertyAPI/#functions_1","title":"Functions","text":""},{"location":"PropertyAPI/#proptestpropertycallable-generators","title":"<code>proptest::property(callable, ...generators)</code>","text":"<p>Creates a <code>Property</code> object from a callable (function, functor, or lambda).</p> <p>Parameters:</p> <ul> <li><code>callable</code>: A callable that defines the property. Can return <code>bool</code> or <code>void</code> (using assertions).</li> <li><code>...generators</code>: Optional generators for property parameters. If not provided, uses default generators (<code>Arbi&lt;T&gt;</code>) for each parameter type.</li> </ul> <p>Returns: <code>Property</code> object</p> <p>Example: <pre><code>auto prop = property([](int a, int b) -&gt; bool {\n    return a + b == b + a;\n});\n\n// With custom generators\nauto prop2 = property([](int a, int b) -&gt; bool {\n    return a + b == b + a;\n}, gen::interval(0, 100), gen::interval(0, 100));\n</code></pre></p> <p>See also: Generators, Arbitrary, Custom Generator</p>"},{"location":"PropertyAPI/#chaining","title":"Chaining","text":"<p><code>proptest::property()</code>, <code>proptest::forAll()</code>, <code>proptest::matrix()</code>, return <code>Property</code> objects. The run methods (<code>.forAll()</code>, <code>.example()</code>, <code>.matrix()</code>) also return <code>Property</code>, enabling fluent chaining. Chaining lets you to test various subdomains for a property in one go:</p> <pre><code>// Chain run methods\nEXPECT_TRUE(property([](int a, int b) { return a + b == b + a; })\n    .forAll(gen::interval(0, 10))\n    .matrix({1, 2}, {3, 4})\n    .example(5, 6));\n\n// Chain free functions\nEXPECT_TRUE(forAll([](int x) { return x &gt;= 0; }, gen::interval(0, 100)).example(42));\n\n// Config flows through the chain\nprop.setSeed(0).setNumRuns(10).forAll().example(42);\n</code></pre> <p>Behavior:</p> Aspect Description Immutable Each step returns a copy; the original is unchanged. <code>p1.example(5); p1.example(6);</code> \u2014 each call uses the same <code>p1</code>. Failure propagates Once a step fails, later steps cannot overturn it. Short-circuiting When a step fails, subsequent steps are skipped (no execution). Configuration preserved <code>setSeed</code>, <code>setNumRuns</code>, etc. flow through the chain."},{"location":"PropertyAPI/#proptestforallcallable","title":"<code>proptest::forAll(callable, ...)</code>","text":"<p>Shorthand for <code>property(callable).forAll()</code>. Creates and immediately runs a property test.</p> <p>Parameters:</p> <ul> <li><code>callable</code>: A callable that defines the property</li> <li><code>...</code>: Optional configuration (C++20 designated initializers) and/or generators</li> </ul> <p>Returns: <code>Property</code> - for chaining (e.g. <code>forAll(...).example(42)</code>). Also provides <code>operator bool()</code> for test result.</p> <p>Example: <pre><code>// Simple usage\nforAll([](int a, int b) -&gt; bool {\n    return a + b == b + a;\n});\n\n// With configuration\nforAll([](int a, int b) -&gt; bool {\n    return a + b == b + a;\n}, {\n    .seed = 12345,\n    .numRuns = 500\n});\n\n// With generators\nforAll([](int a, int b) -&gt; bool {\n    return a + b == b + a;\n}, gen::interval(0, 100), gen::interval(0, 100));\n\n// Chainable: forAll().example(...)\nEXPECT_TRUE(forAll([](int x) -&gt; bool { return x &gt;= 0; }, gen::interval(0, 100)).example(42));\n</code></pre></p>"},{"location":"PropertyAPI/#proptestmatrixcallable-lists","title":"<code>proptest::matrix(callable, ...lists)</code>","text":"<p>Shorthand for <code>property(callable).matrix(...)</code>. Creates and immediately runs a matrix test (Cartesian product).</p> <p>Parameters:</p> <ul> <li><code>callable</code>: A callable that defines the property</li> <li><code>...lists</code>: <code>initializer_list</code> for each parameter, representing all values to test</li> </ul> <p>Returns: <code>Property</code> - for chaining (e.g. <code>matrix(...).example(42)</code>).</p> <p>Example: <pre><code>matrix([](int a, int b) -&gt; bool {\n    return a + b == b + a;\n}, {1, 2, 3}, {4, 5, 6});\n</code></pre></p> <p> </p>"},{"location":"PropertyAPI/#property-class","title":"Property Class","text":"<p>The <code>Property</code> class represents a property test with configurable execution options.</p>"},{"location":"PropertyAPI/#propertyforallgenerators","title":"<code>Property::forAll(...generators)</code>","text":"<p>Runs the property with randomly generated inputs.</p> <p>Parameters:</p> <ul> <li><code>...generators</code>: Optional generators to override or supplement those specified at property creation</li> </ul> <p>Returns: <code>Property</code> copy with accumulated test result (immutable; original unchanged).</p> <p>Example: <pre><code>auto prop = property([](int a, int b) -&gt; bool {\n    return a + b == b + a;\n});\n\nprop.forAll();  // Use default generators\nprop.forAll(gen::interval(0, 100), gen::interval(0, 100));  // Override generators\n\n// Chainable: forAll().matrix().example() \u2014 returns new Property\nEXPECT_TRUE(prop.forAll().matrix({1, 2}, {3, 4}).example(5, 6));\n</code></pre></p> <p>See also: Testing a Property, Configuring test runs</p>"},{"location":"PropertyAPI/#propertyexampleargs","title":"<code>Property::example(...args)</code>","text":"<p>Runs the property once with specific input values.</p> <p>Parameters:</p> <ul> <li><code>...args</code>: Arguments matching the property function's parameters</li> </ul> <p>Returns: <code>Property</code> copy with accumulated test result (immutable; original unchanged).</p> <p>Example: <pre><code>auto prop = property([](int a, int b) -&gt; bool {\n    return a + b == b + a;\n});\n\nprop.example(5, 10);\nprop.example(INT_MIN, INT_MAX);  // Independent of previous call\nEXPECT_TRUE(prop.forAll().example(42));  // Chaining and bool coercion\n</code></pre></p>"},{"location":"PropertyAPI/#propertymatrixlists","title":"<code>Property::matrix(...lists)</code>","text":"<p>Runs the property for all combinations of input values (Cartesian product).</p> <p>Parameters:</p> <ul> <li><code>...lists</code>: <code>initializer_list</code> for each parameter</li> </ul> <p>Returns: <code>Property</code> copy with accumulated test result (immutable; original unchanged).</p> <p>Example: <pre><code>auto prop = property([](int a, int b) -&gt; bool {\n    return a + b == b + a;\n});\n\n// Tests all 9 combinations: (1,4), (1,5), (1,6), (2,4), (2,5), (2,6), (3,4), (3,5), (3,6)\nEXPECT_TRUE(prop.matrix({1, 2, 3}, {4, 5, 6}));\n</code></pre></p>"},{"location":"PropertyAPI/#propertyoperator-bool","title":"<code>Property::operator bool()</code>","text":"<p>Returns the accumulated test result. Enables <code>EXPECT_TRUE(prop.forAll())</code> and <code>if (forAll(...))</code> via implicit conversion. Used on the returned Property from <code>forAll</code>/<code>example</code>/<code>matrix</code>. Failure propagates: once any step fails, later steps cannot overturn it and are skipped (no execution). Configuration preserved: <code>setSeed</code>, <code>setNumRuns</code>, etc. flow through the chain (each step returns a copy that includes the config).</p> <p> </p>"},{"location":"PropertyAPI/#configuration","title":"Configuration","text":"<p>All configuration methods return a reference to <code>Property</code>, allowing method chaining.</p>"},{"location":"PropertyAPI/#propertysetseedseed","title":"<code>Property::setSeed(seed)</code>","text":"<p>Sets the random seed for test execution. Useful for reproducibility.</p> <p>Parameters:</p> <ul> <li><code>seed</code>: <code>uint64_t</code> - Random seed value</li> </ul> <p>Returns: <code>Property&amp;</code></p> <p>Example: <pre><code>prop.setSeed(12345).forAll();\n</code></pre></p> <p>Note: If no seed is specified, current timestamp in milliseconds is used. You can also set it via environment variable <code>PROPTEST_SEED</code>.</p>"},{"location":"PropertyAPI/#propertysetnumrunsruns","title":"<code>Property::setNumRuns(runs)</code>","text":"<p>Sets the number of test runs to execute.</p> <p>Parameters:</p> <ul> <li><code>runs</code>: <code>uint32_t</code> - Number of runs (default: 1000)</li> </ul> <p>Returns: <code>Property&amp;</code></p> <p>Example: <pre><code>prop.setNumRuns(500).forAll();\n</code></pre></p> <p>Note: You can set a global default using <code>PropertyBase::setDefaultNumRuns(num)</code>.</p>"},{"location":"PropertyAPI/#propertysetmaxdurationmsduration","title":"<code>Property::setMaxDurationMs(duration)</code>","text":"<p>Sets the maximum duration for test execution in milliseconds. Test stops when either the number of runs or duration limit is reached (whichever comes first).</p> <p>Parameters:</p> <ul> <li><code>duration</code>: <code>uint32_t</code> - Maximum duration in milliseconds</li> </ul> <p>Returns: <code>Property&amp;</code></p> <p>Example: <pre><code>prop.setMaxDurationMs(5000).forAll();  // Run for at most 5 seconds\n</code></pre></p>"},{"location":"PropertyAPI/#propertysetonstartupcallback","title":"<code>Property::setOnStartup(callback)</code>","text":"<p>Sets a callback function called before each test run.</p> <p>Parameters:</p> <ul> <li><code>callback</code>: <code>Function&lt;void()&gt;</code> - Callback function</li> </ul> <p>Returns: <code>Property&amp;</code></p> <p>Example: <pre><code>prop.setOnStartup([]() {\n    std::cout &lt;&lt; \"Starting test run\" &lt;&lt; std::endl;\n}).forAll();\n</code></pre></p>"},{"location":"PropertyAPI/#propertysetoncleanupcallback","title":"<code>Property::setOnCleanup(callback)</code>","text":"<p>Sets a callback function called after each test run.</p> <p>Parameters:</p> <ul> <li><code>callback</code>: <code>Function&lt;void()&gt;</code> - Callback function</li> </ul> <p>Returns: <code>Property&amp;</code></p> <p>Example: <pre><code>prop.setOnCleanup([]() {\n    std::cout &lt;&lt; \"Test run complete\" &lt;&lt; std::endl;\n}).forAll();\n</code></pre></p>"},{"location":"PropertyAPI/#propertysetconfigconfig","title":"<code>Property::setConfig(config)</code>","text":"<p>Configures multiple options at once using designated initializers.</p> <p>Parameters:</p> <ul> <li><code>config</code>: <code>ForAllConfig</code> - Configuration struct with optional fields:</li> <li><code>.seed</code>: <code>uint64_t</code></li> <li><code>.numRuns</code>: <code>uint32_t</code></li> <li><code>.maxDurationMs</code>: <code>uint32_t</code></li> <li><code>.onStartup</code>: <code>Function&lt;void()&gt;</code></li> <li><code>.onCleanup</code>: <code>Function&lt;void()&gt;</code></li> </ul> <p>Returns: <code>Property&amp;</code></p> <p>Example: <pre><code>prop.setConfig({\n    .seed = 12345,\n    .numRuns = 1000,\n    .maxDurationMs = 5000\n}).forAll();\n</code></pre></p> <p>Note: All fields are optional. This is equivalent to chaining individual setters.</p> <p> </p>"},{"location":"PropertyAPI/#assertion-macros_1","title":"Assertion Macros","text":"<p>Assertion macros verify conditions within property functions. Fatal assertions (<code>PROP_ASSERT_*</code>) stop test execution on failure, while non-fatal expectations (<code>PROP_EXPECT_*</code>) continue testing.</p> <p>Fatal Assertions:</p> <ul> <li><code>PROP_ASSERT(condition)</code> - Assert condition is true</li> <li><code>PROP_ASSERT_TRUE(condition)</code> - Assert condition is true</li> <li><code>PROP_ASSERT_FALSE(condition)</code> - Assert condition is false</li> <li><code>PROP_ASSERT_EQ(A, B)</code> - Assert equality</li> <li><code>PROP_ASSERT_NE(A, B)</code> - Assert not equal</li> <li><code>PROP_ASSERT_LT(A, B)</code> - Assert less than</li> <li><code>PROP_ASSERT_LE(A, B)</code> - Assert less than or equal</li> <li><code>PROP_ASSERT_GT(A, B)</code> - Assert greater than</li> <li><code>PROP_ASSERT_GE(A, B)</code> - Assert greater than or equal</li> <li><code>PROP_ASSERT_STREQ(A, B, N)</code> - Assert string equality (first N characters)</li> </ul> <p>Non-fatal Expectations:</p> <ul> <li><code>PROP_EXPECT(condition)</code> - Expect condition is true</li> <li><code>PROP_EXPECT_TRUE(condition)</code> - Expect condition is true</li> <li><code>PROP_EXPECT_FALSE(condition)</code> - Expect condition is false</li> <li><code>PROP_EXPECT_EQ(A, B)</code> - Expect equality</li> <li><code>PROP_EXPECT_NE(A, B)</code> - Expect not equal</li> <li><code>PROP_EXPECT_LT(A, B)</code> - Expect less than</li> <li><code>PROP_EXPECT_LE(A, B)</code> - Expect less than or equal</li> <li><code>PROP_EXPECT_GT(A, B)</code> - Expect greater than</li> <li><code>PROP_EXPECT_GE(A, B)</code> - Expect greater than or equal</li> <li><code>PROP_EXPECT_STREQ(A, B, N)</code> - Expect string equality (first N characters)</li> </ul> <p>Example: <pre><code>forAll([](int a, int b) {\n    PROP_ASSERT_EQ(a + b, b + a);  // Fatal - stops on failure\n    PROP_EXPECT_GE(a + b, a);      // Non-fatal - continues on failure\n});\n</code></pre></p> <p>See also: Test Control Macros</p> <p> </p>"},{"location":"PropertyAPI/#statistics-and-tagging-macros_1","title":"Statistics and Tagging Macros","text":""},{"location":"PropertyAPI/#prop_statexpression","title":"<code>PROP_STAT(expression)</code>","text":"<p>Collects statistics about expression values. The expression is evaluated for each test run, and a summary is printed at the end showing the distribution of results.</p> <p>Example: <pre><code>forAll([](float f) {\n    PROP_STAT(std::isfinite(f));\n    PROP_STAT(f &gt; 0);\n    PROP_STAT(f &lt; 0);\n}, gen::float32(0.05, 0.05, 0.05));\n</code></pre></p> <p>See also: Test Strategies</p>"},{"location":"PropertyAPI/#prop_tagkey-value","title":"<code>PROP_TAG(key, value)</code>","text":"<p>Categorizes test cases with custom key-value pairs. Both key and value are expressions that are evaluated.</p> <p>Example: <pre><code>forAll([](int x) {\n    if (x &lt; 0) {\n        PROP_TAG(\"sign\", \"negative\");\n    } else if (x &gt; 0) {\n        PROP_TAG(\"sign\", \"positive\");\n    } else {\n        PROP_TAG(\"sign\", \"zero\");\n    }\n});\n</code></pre></p>"},{"location":"PropertyAPI/#prop_classifycondition-key-value","title":"<code>PROP_CLASSIFY(condition, key, value)</code>","text":"<p>Convenience macro that conditionally applies a tag. Equivalent to <code>if (condition) PROP_TAG(key, value)</code>.</p> <p>Example: <pre><code>forAll([](int x, int y) {\n    PROP_CLASSIFY(x == y, \"relationship\", \"equal\");\n    PROP_CLASSIFY(x &gt; y, \"relationship\", \"greater\");\n    PROP_CLASSIFY(x &lt; y, \"relationship\", \"less\");\n});\n</code></pre></p>"},{"location":"PropertyAPI/#stat-assertion-macros","title":"Stat assertion macros","text":"<p>Assert that the ratio of runs where an expression is true falls within bounds. Bounds are ratios in [0, 1]. Assertions are evaluated after the main loop.</p> Macro Condition <code>PROP_STAT_ASSERT_GE(expr, bound)</code> ratio \u2265 bound <code>PROP_STAT_ASSERT_LE(expr, bound)</code> ratio \u2264 bound <code>PROP_STAT_ASSERT_IN_RANGE(expr, min, max)</code> min \u2264 ratio \u2264 max <p>Failure output: When a stat assertion fails, the message includes the source location <code>(file:line)</code> for easy debugging, e.g.:</p> <pre><code>Stat assertion failed: PROP_STAT_ASSERT_GE(a &gt; 0, 0.5) failed: ratio 0 &lt; 0.5 (0/1000) (/path/to/test.cpp:42)\n</code></pre> <p>Example: <pre><code>forAll([](int a) {\n    PROP_STAT_ASSERT_GE(a &gt; 0, 0.5); // a &gt; 0 case must be greater or equal to 50%\n}, gen::interval(1, 100));\n\nforAll([](int a) {\n    PROP_STAT_ASSERT_IN_RANGE(a &gt; 0, 0.5, 1.0);  // Ratio must be in [0.5, 1.0]\n}, gen::interval(1, 100));\n</code></pre></p> <p> </p>"},{"location":"PropertyAPI/#test-control-macros_1","title":"Test Control Macros","text":""},{"location":"PropertyAPI/#prop_discard","title":"<code>PROP_DISCARD()</code>","text":"<p>Skips the current test iteration. The iteration doesn't count toward the total number of runs, and the test will generate additional inputs to meet the configured number of successful runs.</p> <p>Use case: When generated inputs don't meet preconditions for your property test.</p> <p>Example: <pre><code>forAll([](int x, int y) {\n    if (y == 0) {\n        PROP_DISCARD();  // Skip division by zero cases\n    }\n    int result = x / y;\n    PROP_ASSERT(result * y &lt;= x);\n});\n</code></pre></p> <p>Note: If too many cases are discarded, consider using <code>gen::filter()</code> at the generator level instead. See Combinators.</p>"},{"location":"PropertyAPI/#prop_success","title":"<code>PROP_SUCCESS()</code>","text":"<p>Immediately marks the current test iteration as successful and skips any remaining assertions or checks in the property function.</p> <p>Use case: Early exit for trivial cases that you know will pass, optimizing test execution time.</p> <p>Example: <pre><code>forAll([](int x, int y) {\n    if (x == 0 || y == 0) {\n        PROP_SUCCESS();  // Skip expensive checks for trivial cases\n    }\n    PROP_ASSERT(complexProperty(x, y));\n});\n</code></pre></p> <p> </p>"},{"location":"PropertyAPI/#google-test-integration-macros_1","title":"Google Test Integration Macros","text":""},{"location":"PropertyAPI/#expect_for_all","title":"<code>EXPECT_FOR_ALL(...)</code>","text":"<p>Shorthand for <code>EXPECT_TRUE(proptest::forAll(...))</code>. Non-fatal - continues testing on failure.</p> <p>Example: <pre><code>TEST(Arithmetic, Commutativity)\n{\n    EXPECT_FOR_ALL([](int a, int b) {\n        PROP_ASSERT_EQ(a + b, b + a);\n    });\n}\n</code></pre></p>"},{"location":"PropertyAPI/#assert_for_all","title":"<code>ASSERT_FOR_ALL(...)</code>","text":"<p>Shorthand for <code>ASSERT_TRUE(proptest::forAll(...))</code>. Fatal - stops test execution on failure.</p> <p>Example: <pre><code>TEST(Arithmetic, Commutativity)\n{\n    ASSERT_FOR_ALL([](int a, int b) {\n        PROP_ASSERT_EQ(a + b, b + a);\n    });\n}\n</code></pre></p>"},{"location":"PropertyAPI/#expect_matrix","title":"<code>EXPECT_MATRIX(...)</code>","text":"<p>Shorthand for <code>EXPECT_TRUE(proptest::matrix(...))</code>. Takes a callable and <code>initializer_list</code> arguments (same as the <code>matrix</code> free function). Runs the property over the Cartesian product of the given lists. Non-fatal - continues testing on failure.</p> <p>Example: <pre><code>TEST(Arithmetic, MatrixExample)\n{\n    EXPECT_MATRIX([](int a, int b) -&gt; bool {\n        return a + b == b + a;\n    }, {1, 2, 3}, {4, 5, 6});\n}\n</code></pre></p>"},{"location":"PropertyAPI/#assert_matrix","title":"<code>ASSERT_MATRIX(...)</code>","text":"<p>Shorthand for <code>ASSERT_TRUE(proptest::matrix(...))</code>. Takes a callable and <code>initializer_list</code> arguments (same as the <code>matrix</code> free function). Runs the property over the Cartesian product of the given lists. Fatal - stops test execution on failure.</p> <p>Example: <pre><code>TEST(Arithmetic, MatrixExample)\n{\n    ASSERT_MATRIX([](int a, int b) -&gt; bool {\n        return a + b == b + a;\n    }, {1, 2, 3}, {4, 5, 6});\n}\n</code></pre></p> <p> </p>"},{"location":"PropertyAPI/#usage-examples","title":"Usage Examples","text":""},{"location":"PropertyAPI/#basic-property-test","title":"Basic Property Test","text":"<pre><code>#include \"proptest/proptest.hpp\"\n#include &lt;gtest/gtest.h&gt;\n\nusing namespace proptest;\n\nTEST(Arithmetic, AdditionIsCommutative)\n{\n    forAll([](int a, int b) -&gt; bool {\n        return a + b == b + a;\n    });\n}\n</code></pre>"},{"location":"PropertyAPI/#using-assertions","title":"Using Assertions","text":"<pre><code>TEST(Arithmetic, AdditionIsCommutativeWithAssertions)\n{\n    forAll([](int a, int b) {\n        PROP_ASSERT_EQ(a + b, b + a);\n    });\n}\n</code></pre>"},{"location":"PropertyAPI/#custom-generators","title":"Custom Generators","text":"<pre><code>TEST(Arithmetic, AdditionWithCustomRange)\n{\n    forAll([](int a, int b) {\n        PROP_ASSERT_EQ(a + b, b + a);\n    }, gen::interval(0, 100), gen::interval(0, 100));\n}\n</code></pre>"},{"location":"PropertyAPI/#configuration_1","title":"Configuration","text":"<pre><code>TEST(StringUtils, ReverseWithConfiguration)\n{\n    auto prop = property([](const std::string&amp; original) {\n        std::string reversed = reverseString(original);\n        std::string reversedTwice = reverseString(reversed);\n        PROP_ASSERT_EQ(original, reversedTwice);\n    });\n\n    prop.setNumRuns(500)\n        .setSeed(12345)\n        .setMaxDurationMs(5000)\n        .forAll();\n}\n</code></pre>"},{"location":"PropertyAPI/#batch-configuration","title":"Batch Configuration","text":"<pre><code>TEST(StringUtils, ReverseWithBatchConfig)\n{\n    auto prop = property([](const std::string&amp; original) {\n        std::string reversed = reverseString(original);\n        std::string reversedTwice = reverseString(reversed);\n        PROP_ASSERT_EQ(original, reversedTwice);\n    });\n\n    prop.setConfig({\n        .seed = 12345,\n        .numRuns = 500,\n        .maxDurationMs = 5000\n    }).forAll();\n}\n</code></pre>"},{"location":"PropertyAPI/#testing-specific-examples","title":"Testing Specific Examples","text":"<pre><code>TEST(StringUtils, ReverseEdgeCases)\n{\n    auto prop = property([](const std::string&amp; s) {\n        PROP_ASSERT_EQ(s.length(), reverseString(s).length());\n    });\n\n    prop.example(\"\");\n    prop.example(\"a\");\n    prop.example(\"hello world\");\n}\n</code></pre>"},{"location":"PropertyAPI/#matrix-testing","title":"Matrix Testing","text":"<pre><code>TEST(Arithmetic, BoundaryCases)\n{\n    auto prop = property([](int a, int b) -&gt; bool {\n        return a + b == b + a;\n    });\n\n    prop.matrix({INT_MIN, 0, INT_MAX}, {INT_MIN, 0, INT_MAX});\n}\n</code></pre>"},{"location":"PropertyAPI/#statistics-collection","title":"Statistics Collection","text":"<pre><code>TEST(Statistics, InputDistribution)\n{\n    forAll([](int value) {\n        PROP_STAT(value &gt; 0);\n        PROP_STAT(value &lt; 0);\n        PROP_STAT(value == 0);\n        PROP_TAG(\"magnitude\", value &gt; 100 ? \"large\" : \"small\");\n\n        PROP_ASSERT_GE(value * value, 0);\n    });\n}\n</code></pre>"},{"location":"PropertyAPI/#discarding-invalid-inputs","title":"Discarding Invalid Inputs","text":"<pre><code>TEST(Division, NonZeroDenominator)\n{\n    forAll([](int x, int y) {\n        if (y == 0) {\n            PROP_DISCARD();  // Skip division by zero\n        }\n        int result = x / y;\n        PROP_ASSERT(result * y &lt;= x);\n    });\n}\n</code></pre>"},{"location":"PropertyAPI/#related-topics","title":"Related Topics","text":"<ul> <li>Walkthrough - Step-by-step guide to creating property tests</li> <li>Generators - Complete guide to input generators</li> <li>Arbitrary - Default generators for types</li> <li>Custom Generator - Creating generators for custom types</li> <li>Combinators - Combining and transforming generators</li> <li>Generator Examples - Real-world generator usage</li> <li>Shrinking - How counterexamples are simplified</li> <li>Test Strategies - Advanced testing techniques</li> <li>Stateful Testing - Testing state machines</li> <li>Concurrency Testing - Testing concurrent code</li> </ul>"},{"location":"Shrinking/","title":"Simplifying Failed Inputs (Shrinking)","text":"<p>New to property-based testing? Start with the Walkthrough for a step-by-step guide. Shrinking happens automatically when a property fails\u2014you don't need to configure it. This page explains how it works and when it helps.</p> <p>When a property fails, <code>cppproptest</code> finds a counterexample\u2014an input that disproves the property. Shrinking then simplifies that counterexample to make debugging easier. All built-in generators and combinators support shrinking out of the box.</p> <p> </p>"},{"location":"Shrinking/#overview","title":"Overview","text":"Concept Description Counterexample An input that causes the property to fail Shrinking The process of finding a simpler counterexample that still fails Shrinkable A wrapper that carries a value and its shrink candidates (created internally by generators) <p>Example: Assume a property fails with <code>a = -13680124, b = 7524.68454e-14, c = true</code>. After shrinking, you might get <code>a = 0, b = 0, c = true</code>\u2014if <code>a</code> and <code>b</code> have no relation to the failure condition and only <code>c</code> matters.</p> <p> </p>"},{"location":"Shrinking/#how-shrinking-works","title":"How Shrinking Works","text":"<p>When <code>forAll</code> detects a failure, it runs a shrinking phase. It repeatedly tries simpler variants of the failing input (while keeping the constraint given when it was generated). If a simpler variant still fails the test, the framework keeps it and continues until there is no more that fails. The result is a minimal counterexample that still reproduces the failure.</p> <p>This automates the manual debugging step of finding which arguments matter and simplifying them to isolate the root cause as much as possible.</p> <p> </p>"},{"location":"Shrinking/#shrinkability-by-type","title":"Shrinkability by Type","text":"<p><code>cppproptest</code> uses type-specific heuristics for what counts as \"simpler\". For example, simplifying some basic types can have following approaches:</p> Type Simpler means Booleans <code>false</code> is simpler than <code>true</code> Integers Smaller absolute value; remove sign (e.g., <code>-34</code> \u2192 <code>34</code>, <code>16384</code> \u2192 <code>1024</code>) Floats Smaller exponent; fewer digits (e.g., <code>12e55</code> \u2192 <code>12e20</code>, <code>-29.5134</code> \u2192 <code>-29</code>) Strings Fewer characters, simpler characters. (e.g., <code>\"Hello world!\"</code> \u2192 <code>\"Hello\"</code>) Containers Fewer elements, simpler elements. (e.g., <code>[0,1,2,3,4,5]</code> \u2192 <code>[0,0,0]</code>) <p> </p>"},{"location":"Shrinking/#when-shrinking-helps","title":"When Shrinking Helps","text":"<ul> <li>Debugging \u2014 A minimal counterexample is easier to reason about than a large random one. It's often a single parameter that's causing the failure while the rest are irrelevant.</li> <li>Test design</li> <li>Reproducibility \u2014 The shrunk counterexample is reported with the failure; you can use it to reproduce the bug locally.</li> </ul>"},{"location":"Shrinking/#custom-generators-and-shrinking","title":"Custom Generators and Shrinking","text":"<p>When building custom generators, you wrap values with <code>make_shrinkable&lt;T&gt;(value)</code>. The default <code>make_shrinkable</code> provides no shrink candidates (the value is already minimal). For custom shrinking behavior, you can provide alternative shrink candidates\u2014see the CustomGenerator and shrinker APIs for advanced use.</p> <p> </p>"},{"location":"Shrinking/#related-topics","title":"Related Topics","text":"<ul> <li>Walkthrough - Step-by-step guide for creating property tests</li> <li>Property API - Using <code>forAll</code> and property configuration</li> <li>Generators - Built-in generators (all support shrinking)</li> <li>Combinators - Generator combinators (all support shrinking)</li> <li>CustomGenerator - Building custom generators with <code>make_shrinkable</code></li> </ul>"},{"location":"StatefulTesting/","title":"Stateful Testing","text":"<p>While property-based testing suits well with functions and stateless objects, it's also useful in testing for various state changes with ease. Typical properties we can test with stateful tests are as following:</p> <ul> <li>Test for consistency of internal state</li> <li>Test for memory leaks</li> <li>Test for concurrent accesses (see Concurrency Testing for more)</li> </ul> <p>The key idea of stateful testing with <code>cppproptest</code> is to generate state changes.</p> <ol> <li>Define action generators: Define <code>action</code>s that each represents unit of state change - e.g. For a numeric object, calling <code>.multiply(int multiplier)</code> method with a numeric multiplier as an argument, calling <code>.divide(int divisor)</code> method, etc.</li> <li>Build an action list generator: we then need a generator for the <code>action</code> types that can build a list of actions and pass required arguments to the selected actions</li> <li>Run the stateful test</li> </ol> <p>Say, you are to write stateful test for your <code>MyVector</code>, which is a linear container for integers.</p> <pre><code>class MyVector {\n    void push_back(int val);\n    int pop_back();\n    int size();\n    int&amp; at(int pos);\n    void clear();\n};\n</code></pre> <p>You first need to define actions for each state change.</p>"},{"location":"StatefulTesting/#using-action-functions","title":"Using Action Functions","text":"<p>An <code>Action</code> or a <code>SimpleAction</code> is formally defined as a functor object of the form:</p> <p><code>Action&lt;ObjectType,ModelType&gt;</code>: <pre><code>(ObjectType&amp;, ModelType&amp;) -&gt; void\n</code></pre></p> <p><code>SimpleAction&lt;ObjectType&gt;</code>: <pre><code>(ObjectType&amp;) -&gt; void\n</code></pre></p> <p><code>ObjectType</code> refers to the type of the stateful object of our concern. <code>ModelType</code> indicates an optional object type with which we'd like to check our stateful object. This additional object is called a model. For example, you can mark number of elements in a model to track the inserted or removed elements in a container object. Or you could closely compare your object with an already validated implementation that works similar to yours.</p>"},{"location":"StatefulTesting/#option-1-simpleaction-working-without-a-model","title":"Option 1: <code>SimpleAction</code> - Working without a model","text":"<pre><code>(ObjectType&amp;) -&gt; void\n</code></pre> <p>You can use <code>SimpleAction</code> and its variant if you do not intend to use a model object. Let's discuss this simper variant first. The function takes an <code>ObjectType</code> reference. You will typically be defining a <code>SimpleAction</code> with a lambda. Our first goal is to create a generator for our action. A generator for an action with no arguments such as <code>pop_back()</code> can be defined as:</p> <pre><code>#include \"proptest/statefultest.hpp\"\nusing namespace proptest;\nusing namespace proptest::stateful;\n\n// ...\n\nauto popBackGen = just(SimpleAction&lt;MyVector&gt;([](MyVector&amp; obj) {\n    obj.pop_back();\n}));\n</code></pre> <p>Notice the usage of <code>just</code> generator combinator which will always generate the same action. Compare with following <code>push_back()</code>'s action generator that requires an integer argument:</p> <pre><code>auto pushBackGen = gen::int32().map&lt;SimpleAction&lt;MyVector&gt;&gt;([](int value) {\n    return SimpleAction&lt;MyVector&gt;([value](MyVector&amp; obj) {\n        obj.push_back(value);\n    });\n});\n</code></pre> <p>Here you can see an integer generator is transformed as an action generator. The outer lambda returns an action that calls <code>push_back()</code> with the integer argument <code>value</code>.</p> <p>You can add various assertions in the action. Any failed assertion will be reported and analyzed, as in ordinary property tests.</p> <p>With each action generator defined, we would typically combine these generators as one, using <code>oneOf</code> combinator:</p> <pre><code>auto actionGen = oneOf&lt;SimpleAction&lt;MyAction&gt;&gt;(pushBackGen, popBackGen, clearGen);\n</code></pre> <p>This will generate either of 3 actions, with evenly distributed probability (1/3).</p> <p>Finally, we can define a stateful property by calling <code>statefulProperty&lt;ObjectType&gt;()</code>. This method requires an initial state generator, and the <code>actionGen</code> we've just obtained. Calling <code>statefulProperty::go()</code> will execute the stateful property test.</p> <pre><code>// we can generate initial object from an arbitrary, assuming we have an Arbi&lt;MyVector&gt; defined\nauto prop = statefulProperty&lt;T&gt;(\n    /* initial state generator */ Arbi&lt;MyVector&gt;(),\n    /* action generator */ actionGen);\nprop.go();\n\n// ...\n\n// or, we can just initialize the object to an empty object\nauto prop = statefulProperty&lt;T&gt;(\n    /* initial state generator */ lazy&lt;MyVector&gt;([]() { return MyVector(); }),\n    /* action generator */ actionGen);\nprop.go();\n</code></pre>"},{"location":"StatefulTesting/#putting-it-together","title":"Putting it together:","text":"<pre><code>class MyVector {\n    void push_back(int val) { ... }\n    int pop_back() { ... }\n    int size() { ... }\n    int&amp; at(int pos) { ... }\n    void clear() { ... }\n};\n\nTEST(MyVectorTest, Stateful)\n{\n    auto popBackGen = just(SimpleAction&lt;MyVector&gt;([](MyVector&amp; obj) {\n        if(obj.size() == 0)\n            return;\n        int size = obj.size();\n        obj.pop_back();\n        PROP_ASSERT(obj.size() == size - 1);\n    }));\n\n    auto pushBackGen = gen::int32().map&lt;SimpleAction&lt;MyVector&gt;&gt;([](int value) {\n        return [value](MyVector&amp; obj) {\n            int size = obj.size();\n            obj.push_back(value);\n            PROP_ASSERT(obj.size() == size + 1);\n        };\n    });\n\n    auto clearGen = just(SimpleAction&lt;MyVector&gt;([](MyVector&amp; obj) {\n        obj.clear();\n        PROP_ASSERT(obj.size() == 0);\n    }));\n\n    auto actionGen = oneOf&lt;SimpleAction&lt;MyVector&gt;&gt;(pushBackGen, popBackGen, weightedGen&lt;SimpleAction&lt;MyVector&gt;&gt;(clearGen, 0.1));\n    // `oneOf` can take weights, so you can adjust rate of generation of an action\n    //    auto actionGen = oneOf&lt;SimpleAction&lt;MyVector&gt;&gt;(pushBackGen, popBackGen, weightedGen&lt;SimpleAction&lt;MyVector&gt;&gt;(clearGen, 0.1));\n    auto prop = statefulProperty&lt;MyVector&gt;(\n        /* initial state generator */ lazy&lt;MyVector&gt;([]() { return MyVector(); }),\n        /* action generator */ actionGen);\n    // Tests massive cases with randomly generated action sequences\n    prop.go();\n}\n</code></pre>"},{"location":"StatefulTesting/#option-2-action-working-with-a-model","title":"Option 2: <code>Action</code> - Working with a model","text":"<p>If you need a model for advanced tracking of state changes, use <code>Action</code> instead of <code>SimpleAction</code>. <code>Action</code> takes additional parameter indicating the model type. Let's define our model for tracking number of elements for <code>MyVector</code></p> <pre><code>// our simple model that tracks number of elements\nstruct Counter {\n    Counter(int n) : num(n) {}\n    int num;\n};\n</code></pre> <p>With this defined, we can continue defining our actions.</p> <pre><code>auto popBackGen = just(Action&lt;MyVector, Counter&gt;([](MyVector&amp; obj, Counter&amp; counter) {\n    if(obj.size() == 0)\n        return;\n    obj.pop_back();\n    counter.num--;\n}));\n</code></pre> <p>You can use <code>oneOf&lt;Action&lt;ObjectType, ModelType&gt;&gt;</code> to get the combined action generator:</p> <pre><code>auto actionGen = oneOf&lt;Action&lt;MyVector, Counter&gt;&gt;(pushBackGen, popBackGen, clearGen);\n</code></pre> <p>Finally, we can define a stateful property by calling <code>statefulProperty&lt;ObjectType,ModelType&gt;()</code>. This method requires an initial state generator, and the <code>actionGen</code> we've just obtained. Compared to <code>SimpleAction</code> case, it additionally requires a model factory in the form of <code>ObjectType&amp; -&gt; ModelType</code>. This factory is to induce initial model from initial object. Calling <code>statefulProperty::go()</code> will execute the stateful property test.</p> <pre><code>auto prop = statefulProperty&lt;T&gt;(\n    /* initial state generator */ Arbi&lt;MyVector&gt;(),\n    /* model factory */ [](MyVector&amp; vec) { return Counter(vec.size()); },\n    /* action generator */ actionGen);\nprop.go();\n</code></pre> <p>While the model in this example is simple, you may choose to use more complex ones. It's often a clever idea to use an existing, well validated implementation as model. For example, we could use <code>std::vector&lt;int&gt;</code> as model and perform the actions on both <code>MyVector</code> and <code>std::vector</code>. We assure <code>MyVector</code> works correctly by comparing element-wise with the <code>std::vector</code> model object that has undergone the same state changes.</p>"},{"location":"StatefulTesting/#putting-it-together_1","title":"Putting it together:","text":"<pre><code>class MyVector {\n    void push_back(int val) { ... }\n    int pop_back() { ... }\n    int size() { ... }\n    int&amp; at(int pos) { ... }\n    void clear() { ... }\n};\n\n// our simple model that tracks number of elements\nstruct Counter {\n    Counter(int n) : num(n) {}\n    int num;\n};\n\nTEST(MyVectorTest, Stateful)\n{\n    auto popBackGen = just(Action&lt;MyVector, Counter&gt;([](MyVector&amp; obj, Counter&amp; cnt) {\n        if(obj.size() == 0)\n            return;\n        obj.pop_back();\n        cnt.num--;\n        PROP_ASSERT(cnt.num == obj.size());\n    }));\n\n    auto pushBackGen = gen::int32().map&lt;Action&lt;MyVector, Counter&gt;&gt;([](int value) {\n        return [value](MyVector&amp; obj) {\n            obj.push_back(value);\n            cnt.num++;\n            PROP_ASSERT(cnt.num == obj.size());\n        };\n    });\n\n    auto clearGen = just(Action&lt;MyVector, Counter&gt;([](MyVector&amp; obj) {\n        obj.clear();\n        cnt.num = 0;\n        PROP_ASSERT(cnt.num == obj.size());\n    }));\n\n    // combine action generators\n    auto actionGen = oneOf&lt;Action&lt;MyVector, Counter&gt;&gt;(pushBackGen, popBackGen, clearGen);\n    // oneOf() can take weights, so you can adjust rate of generation of an action\n    //    auto actionGen = oneOf&lt;Action&lt;MyVector, Counter&gt;&gt;(pushBackGen, popBackGen, weightedGen&lt;Action&lt;MyVector, Counter&gt;&gt;(clearGen, 0.1));\n    auto prop = statefulProperty&lt;MyVector, Counter&gt;(\n        /* initial state generator */ Arbi&lt;MyVector&gt;(),\n        /* initial model factory */ [](MyVector&amp; vec) { return Counter(vec.size()); },\n        /* action generator */ actionGen);\n    // Tests massive cases with randomly generated action sequences\n    prop.go();\n}\n</code></pre>"},{"location":"StatefulTesting/#debugging-stateful-test-failures","title":"Debugging stateful test failures","text":"<p>A stateful test is succesful if all tried combinations were complete without issues. On the other hand, a failed assertion or an unexpected exception would end up with a stateful test failure. The framework will print the failed condition and tried input combinations so that you can debug the failure. Among the <code>args</code>, the first arg is the initial state, and the second one is the action list:</p> <pre><code>Falsifiable, after 12 tests: vec.size() == count (test/test_state_func.cpp:111)\n  with args: { [ 1882384569, -1157159508, ..., 128, 32768, 840506558 ], [ Action&lt;?&gt;, Action&lt;?&gt;, Action&lt;?&gt;, ..., Action&lt;?&gt; ] }\n</code></pre> <p>Note that, by default, an <code>Action</code> or a <code>SimpleAction</code> has no distinctive description. This is why there are indistinguishable <code>Action&lt;?&gt;</code>s printed in the action list. This can be avoided by prepending a description to each action constructor:</p> <pre><code>// action with no argument\nauto clearGen = just(SimpleAction&lt;MyVector&gt;&gt;(\"Clear\", [](MyVector&amp; obj) {\n    // ...\n}));\n\n// action with arguments can be printed nicely with a stringstream\nauto pushBackGen = gen::int32().map&lt;SimpleAction&lt;MyVector&gt;&gt;([](int value) {\n    std::stringstream str;\n    str &lt;&lt; \"PushBack(\" &lt;&lt; value &lt;&lt; \")\";\n    return SimpleAction(str.str(), [value](MyVector&amp; obj) {\n        // ...\n    });\n});\n</code></pre> <p>Now you can see the actions are correctly printed:</p> <pre><code>Falsifiable, after 1 tests: vec.size() &lt; 5 (test/test_state_func.cpp:111)\n  with args: { [ 1882384569, -1157159508, ..., 128, 32768, 840506558 ], [ PushBack(1894834799), PopBack, Clear, ..., PushBack(814265512) ] }\n</code></pre>"},{"location":"StatefulTesting/#action-callbacks-setonactionstart-setonactionend","title":"Action callbacks: <code>setOnActionStart</code> / <code>setOnActionEnd</code>","text":"<p>For properties like \"no intermediate state violates the invariant\" (<code>\u2200 \u2200 \u00ac\u2203</code>), you need to assert after every action, not just at the end. Instead of repeating assertions in every action, use <code>setOnActionEnd</code> to centralize invariant checks:</p> <pre><code>auto prop = statefulProperty&lt;MyVector&gt;(Arbi&lt;MyVector&gt;(), actionGen);\nprop.setOnActionEnd([](MyVector&amp; vec, EmptyModel&amp;) {\n    PROP_ASSERT(vec.size() &gt;= 0);           // Invariant: size is non-negative\n});\nprop.go();\n</code></pre> Callback When it runs <code>setOnActionStart(obj, model)</code> Before each action (including before the first) <code>setOnActionEnd(obj, model)</code> After each action <p>Use <code>setOnActionEnd</code> for invariant checks; use <code>setOnActionStart</code> for pre-condition checks or debugging. Both receive <code>(ObjectType&amp;, ModelType&amp;)</code> (use <code>EmptyModel&amp;</code> when using <code>SimpleAction</code>).</p>"},{"location":"StatefulTesting/#configuring-stateful-test-runs","title":"Configuring stateful test runs","text":"<p>You can alter some of test characteristics of stateful test runs.</p> <ul> <li>Random seed</li> <li>Number of runs</li> <li>Maximum time duration of test runs</li> </ul> <pre><code>auto prop = statefulProperty(...);\n// set random seed\nprop.setSeed(5464561L);\n// number of sequences to be tested\nprop.setNumRuns(10000);\n// maximum time duration for go() is 60 seconds\nprop.setMaxDurationMs(60*1000);\nprop.go();\n// or you can simply chain the property:\nprop.setSeed(0).setNumRuns(1000).setMaxDurationMs(10000).go();\n</code></pre>"},{"location":"StatefulTesting/#alternative-style-using-action-classes","title":"Alternative Style: Using Action Classes","text":"<p>There are actually two styles of stateful testing - one with action functions(lambda) and one with action classes. While the first style using functions are easier to use and understand, the second style is more formal way of doing stateful testing. You may choose to use either style. Both have similar process of defining and running stateful tests. See the separate page for detail. Both styles are similar in terms of expressive power.</p>"},{"location":"StatefulTesting/#further-topics","title":"Further topics","text":"<ul> <li>See Concurrency Testing for testing for concurrent changes of a stateful object.</li> </ul>"},{"location":"StatefulTestingStyle2/","title":"Stateful Testing","text":""},{"location":"StatefulTestingStyle2/#style-2-using-action-classes","title":"Style 2: Using Action Classes","text":""},{"location":"StatefulTestingStyle2/#understanding-action","title":"Understanding <code>Action</code>","text":"<p>In the second style, you will define actions by defining an <code>Action</code> or a <code>SimpleAction</code> abstract class with following signatures:</p> <pre><code>template &lt;typename ObjectType, typename ModelType&gt;\nstruct Action\n{\n    virtual bool precondition(const ObjectType&amp;, const ModelType&amp;) { ... }\n\n    virtual bool run(ObjectType&amp;, ModelType&amp;) { ... }\n};\n\ntemplate &lt;typename ObjectType&gt;\nstruct SimpleAction\n{\n    virtual bool precondition(const ObjectType&amp;) { ... }\n\n    virtual bool run(ObjectType&amp;) { ... }\n};\n</code></pre> <p><code>ObjectType</code> is the target stateful object type. In this case, <code>MyVector</code> is the <code>ObjectType</code> type. <code>ModelType</code> is optional structure to hold useful data for validation of the <code>ObjectType</code> based on some model, throughout the test sequence.</p> <p>You would prefer to use <code>SimpleAction</code> if you don't need a model structure, and <code>Action</code> if you need one.</p> <ul> <li><code>precondition</code> is called to check if an action in the sequence is applicable to current state. If it's not the action is skipped.<ul> <li>Overriding <code>precondition</code> is optional and returns <code>true</code> by default</li> </ul> </li> <li><code>run</code> is called to actually apply the state change and perform validations against your model after the state change</li> </ul> <pre><code>template &lt;typename ObjectType, typename ModelType&gt;\nstruct Action\n{\n    virtual bool precondition(const ObjectType&amp; system, const ModelType&amp;) { ... }\n\n    virtual bool run(ObjectType&amp; system, ModelType&amp;) { ... }\n};\n</code></pre>"},{"location":"StatefulTestingStyle2/#defining-actions","title":"Defining Actions","text":"<p>For the listed methods that might change the state of a <code>MyVector</code>, we would write <code>Action</code>s for each.</p> <pre><code>void push_back(int val);\nint pop_back();\nint&amp; at(int pos);\nvoid clear();\n</code></pre> <pre><code>struct PushBack : public SimpleAction&lt;MyVector&gt; {\n    int val;\n\n    PushBack(int val) : val(val) {\n    }\n\n    bool run(MyVector&amp; vector) {\n        vector.push_back(val);\n    }\n};\n\nstruct PopBack : public SimpleAction&lt;MyVector&gt; {\n    bool precondition(MyVector&amp; vector) {\n        return vector.size() &gt; 0;\n    }\n\n    bool run(MyVector&amp; vector) {\n        vector.pop_back(val);\n    }\n};\n\nstruct SetAt : public SimpleAction&lt;MyVector&gt; {\n    int pos;\n    int val;\n\n    SetAt(int pos, int val) : pos(pos), val(val) {\n    }\n\n    bool precondition(MyVector&amp; vector) {\n        return pos &lt; vector.size();\n    }\n\n    bool run(MyVector&amp; vector) {\n        vector.at(pos) = val;\n    }\n};\n\nstruct Clear : public SimpleAction&lt;MyVector&gt; {\n    bool run(MyVector&amp; vector) {\n        vector.clear(val);\n    }\n};\n</code></pre>"},{"location":"StatefulTestingStyle2/#generating-action-sequence","title":"Generating <code>Action</code> sequence","text":"<p>With our <code>Action</code>s properly defined, we can generate a sequence of <code>Action</code>s. <code>actionClasses</code> function is a useful shorthand for <code>oneOf</code> generator combinator that is specialized for generating <code>Action</code> Sequences.</p> <pre><code>        auto actionListGen = actionListGenOf&lt;SimpleAction&lt;MyVector&gt;&gt;(\n        // int -&gt; PushBack(int)\n        transform&lt;int, std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;(\n            gen::int32(), [](const int&amp; value) { return std::make_shared&lt;PushBack&gt;(value); }),\n\n        // Popback()\n        just&lt;std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;([]() { return std::make_shared&lt;PopBack&gt;(); }),\n\n        // (int, int) -&gt; SetAt(int, int)\n        transform&lt;int, std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;(\n            gen::pair&lt;int,int&gt;(), [](const std::pair&lt;int,int&gt;&amp; posAndVal) { return std::make_shared&lt;SetAt&gt;(posAndVal.first, posAndVal.second); }),\n\n        // Clear()\n        just&lt;std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;([]() { return std::make_shared&lt;Clear&gt;(); })\n    );\n</code></pre> <p>This defines a generator for action sequences that randomly chooses <code>push_back</code>, <code>pop_back</code>, <code>at</code>, and <code>clear</code> methods for <code>MyVector</code> with arguments.</p>"},{"location":"StatefulTestingStyle2/#running-stateful-tests","title":"Running stateful tests","text":"<p>Finally, we will call <code>statefulProperty::forAll</code> to perform generation of action sequences and run the tests. You should supply generator for initial state of <code>MyVector</code> to start with.</p> <pre><code>auto prop = statefulProperty&lt;SimpleAction&lt;MyVector&gt;&gt;(Arbi&lt;MyVector&gt;(), actionListGen)\nprop.forAll();\n</code></pre>"},{"location":"TestStrategies/","title":"Test Strategies","text":"<p>This page is work in progress</p> <ul> <li>Multiple test options for differing degree of exploration<ul> <li>Keep main branches with fixed seeds for reliable validation</li> <li>Randomized hyper-parameters for controlling which parts to explore more</li> </ul> </li> </ul>"},{"location":"Walkthrough/","title":"Creating Your First Property Test: A Step-by-Step Walkthrough","text":"<p>This guide walks you through creating property-based tests with <code>cppproptest</code> from scratch. We'll start with a simple example and gradually build up to more complex scenarios.</p>"},{"location":"Walkthrough/#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have:</p> <ul> <li><code>cppproptest</code> integrated into your project (see Getting Started)</li> <li>A test framework (Google Test is used in these examples)</li> <li>Basic understanding of C++ lambdas</li> </ul>"},{"location":"Walkthrough/#step-1-your-first-property-test","title":"Step 1: Your First Property Test","text":"<p>Let's start with the simplest possible property test - testing that addition is commutative.</p>"},{"location":"Walkthrough/#complete-example","title":"Complete Example","text":"<pre><code>#include \"proptest/proptest.hpp\"\n#include \"&lt;gtest/gtest.h&gt;\"\n\nusing namespace proptest;\n\nTEST(Arithmetic, AdditionIsCommutative)\n{\n    forAll([](int a, int b) -&gt; bool {\n        return a + b == b + a;\n    });\n}\n</code></pre>"},{"location":"Walkthrough/#breaking-it-down","title":"Breaking It Down","text":"<ol> <li> <p>Includes:</p> <ul> <li><code>proptest/proptest.hpp</code> - Main header with all property testing functionality</li> <li><code>&lt;gtest/gtest.h&gt;</code> - Google Test integration</li> </ul> </li> <li> <p>Using namespace: <code>using namespace proptest;</code> gives you access to <code>forAll</code>, <code>property</code>, <code>gen</code>, etc.</p> </li> <li> <p>Test structure: This is a standard Google Test <code>TEST</code> macro. The property test runs inside it.</p> </li> <li> <p>The <code>forAll</code> function: This is the simplest way to run a property test. It:</p> <ul> <li>Takes a callable (here, a lambda) that defines your property</li> <li>Automatically generates random inputs for each parameter</li> <li>Runs the property multiple times (default: 1000 runs)</li> <li>Reports failures if the property doesn't hold</li> </ul> </li> </ol> <p>See Property API Reference for complete details on <code>forAll</code> and other property testing functions.</p> <ol> <li> <p>The property function:</p> <ul> <li>Parameters <code>int a, int b</code> - these will be randomly generated</li> <li>Return type <code>bool</code> - <code>true</code> means the property holds, <code>false</code> means it fails</li> <li>Body: <code>return a + b == b + a;</code> - the property we're testing</li> </ul> </li> </ol>"},{"location":"Walkthrough/#running-the-test","title":"Running the Test","text":"<p>When you run this test, <code>cppproptest</code> will:</p> <ul> <li>Generate 1000 random pairs of integers</li> <li>Call your lambda with each pair</li> <li>Verify that <code>a + b == b + a</code> for all pairs</li> <li>If any pair fails, it will report the failure and attempt to 'shrink' it to a simpler counterexample (see Shrinking for details)</li> </ul>"},{"location":"Walkthrough/#step-2-using-assertions-instead-of-return-values","title":"Step 2: Using Assertions Instead of Return Values","text":"<p>Instead of returning <code>bool</code>, you can use assertions. This is often more readable and provides better error messages on failures:</p> <pre><code>TEST(Arithmetic, AdditionIsCommutativeWithAssertions)\n{\n    forAll([](int a, int b) {\n        PROP_ASSERT_EQ(a + b, b + a);\n    });\n}\n</code></pre> <p>Key differences:</p> <ul> <li>No return type needed (implicitly <code>void</code>)</li> <li><code>PROP_ASSERT_EQ</code> provides detailed failure messages</li> <li>Test case stops immediately on first failure (fatal assertion)</li> </ul> <p>Available assertion macros:</p> <ul> <li><code>PROP_ASSERT_EQ(A, B)</code> - Assert equality</li> <li><code>PROP_ASSERT_NE(A, B)</code> - Assert not equal</li> <li><code>PROP_ASSERT_LT(A, B)</code> - Assert less than</li> <li><code>PROP_ASSERT_LE(A, B)</code> - Assert less than or equal</li> <li><code>PROP_ASSERT_GT(A, B)</code> - Assert greater than</li> <li><code>PROP_ASSERT_GE(A, B)</code> - Assert greater than or equal</li> <li><code>PROP_EXPECT_*</code> - Non-fatal versions (continues testing on failure)</li> </ul> <p>See Property API Reference - Using Assertions for the complete list of assertion macros.</p>"},{"location":"Walkthrough/#step-3-specifying-custom-generators","title":"Step 3: Specifying Custom Generators","text":"<p>By default, <code>forAll</code> uses built-in generators (arbitraries) for each parameter type. You can specify custom generators to control the input domain. See Generators for a complete list of available generators and Arbitrary for details on default generators.</p> <pre><code>TEST(Arithmetic, AdditionWithCustomRange)\n{\n    forAll([](int a, int b) {\n        PROP_ASSERT_EQ(a + b, b + a);\n    }, gen::interval(0, 100), gen::interval(0, 100));\n}\n</code></pre> <p>What changed:</p> <ul> <li>Added two generator arguments: <code>gen::interval(0, 100)</code></li> <li><code>a</code> and <code>b</code> will now only be generated in the range [0, 100]</li> <li>This is useful for testing specific ranges or avoiding problematic values</li> </ul> <p>Some common generator functions:</p> <ul> <li><code>gen::interval(min, max)</code> - Generate integers in a range</li> <li><code>gen::elementOf(values...)</code> - Generate one of the specified values</li> <li><code>gen::just(value)</code> - Always generate the same value</li> <li><code>gen::string()</code> - Generate random strings</li> <li><code>gen::vector&lt;T&gt;()</code> - Generate random vectors</li> </ul> <p>Learn more:</p> <ul> <li>Generators - Complete guide to all built-in generators</li> <li>Combinators - Combine generators to create new ones (e.g., <code>map</code>, <code>filter</code>, <code>flatMap</code>)</li> <li>Gen Namespace - Overview of the <code>gen</code> namespace</li> <li>Generator Examples - Real-world examples of generator usage</li> </ul>"},{"location":"Walkthrough/#step-4-testing-a-real-function","title":"Step 4: Testing a Real Function","text":"<p>Let's test an actual function from your codebase. Suppose you have a function that reverses a string:</p> <pre><code>// Your code (e.g., in a header file)\nstd::string reverseString(const std::string&amp; str);\n\n// Your test\nTEST(StringUtils, ReverseTwiceIsIdentity)\n{\n    forAll([](const std::string&amp; original) {\n        std::string reversed = reverseString(original);\n        std::string reversedTwice = reverseString(reversed);\n        PROP_ASSERT_EQ(original, reversedTwice);\n    });\n}\n</code></pre> <p>Property being tested: Reversing a string twice should yield the original string.</p> <p>What's happening:</p> <ul> <li><code>original</code> is a randomly generated string (see Generators - String Generators for string generation options)</li> <li>We reverse it once, then reverse the result</li> <li>We verify the final result equals the original</li> </ul>"},{"location":"Walkthrough/#step-45-understanding-parameter-types","title":"Step 4.5: Understanding Parameter Types","text":"<p>In the examples so far, we've used different parameter styles - value types like <code>int a</code> and const references like <code>const std::string&amp; original</code>. Both work identically with <code>cppproptest</code> while the latter is often preferred to avoid copy-construction.</p> <p>Value types vs const references:</p> <ul> <li>Value types: <code>int</code>, <code>std::string</code>, <code>std::vector&lt;int&gt;</code> - Parameters are passed by value</li> <li>Const references: <code>const int&amp;</code>, <code>const std::string&amp;</code>, <code>const std::vector&lt;int&gt;&amp;</code> - Parameters are passed by const reference</li> </ul> <p>How generators are selected: The library automatically selects the appropriate generator based on the underlying type, regardless of whether you use value or const reference:</p> <pre><code>// These are equivalent - both use Arbi&lt;int&gt;\nforAll([](int a) { ... });\nforAll([](const int&amp; a) { ... });\n\n// These are equivalent - both use Arbi&lt;std::string&gt;\nforAll([](std::string s) { ... });\nforAll([](const std::string&amp; s) { ... });\n</code></pre> <p>When to use which:</p> <ul> <li>Use value types for simple, cheap-to-copy types: <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, etc.</li> <li>Use const references for larger or expensive-to-copy types: <code>std::string</code>, <code>std::vector&lt;T&gt;</code>, <code>std::map&lt;K,V&gt;</code>, custom structs, etc.</li> </ul> <p>Example showing both styles:</p> <pre><code>TEST(ParameterTypes, ValueAndReference)\n{\n    // Value type for simple int\n    forAll([](int value) {\n        PROP_ASSERT_GE(value * value, 0);\n    });\n\n    // Const reference for string (avoids copying)\n    forAll([](const std::string&amp; str) {\n        PROP_ASSERT_EQ(str.length(), str.length());\n    });\n\n    // Mixed: const reference for vector, value for int\n    forAll([](const std::vector&lt;int&gt;&amp; vec, int index) {\n        if (index &lt; vec.size()) {\n            PROP_ASSERT_GE(vec[index], INT_MIN);\n        }\n    });\n}\n</code></pre> <p>The generator selection happens automatically - you don't need to specify different generators for value vs const reference types.</p>"},{"location":"Walkthrough/#step-5-using-the-property-api-for-more-control","title":"Step 5: Using the <code>property()</code> API for More Control","text":"<p>The <code>property()</code> function gives you more control and flexibility:</p> <pre><code>TEST(StringUtils, ReverseWithPropertyAPI)\n{\n    auto prop = property([](const std::string&amp; original) {\n        std::string reversed = reverseString(original);\n        std::string reversedTwice = reverseString(reversed);\n        PROP_ASSERT_EQ(original, reversedTwice);\n    });\n\n    // Configure and run\n    prop.setNumRuns(500).forAll();\n}\n</code></pre> <p>You can also set a maximum duration to limit how long the test runs:</p> <pre><code>TEST(StringUtils, ReverseWithTimeLimit)\n{\n    auto prop = property([](const std::string&amp; original) {\n        std::string reversed = reverseString(original);\n        std::string reversedTwice = reverseString(reversed);\n        PROP_ASSERT_EQ(original, reversedTwice);\n    });\n\n    // Run for at most 5 seconds, or until 1000 runs complete (whichever comes first)\n    prop.setMaxDurationMs(5000).setNumRuns(1000).forAll();\n}\n</code></pre> <p>You can also use <code>setConfig()</code> to configure multiple options at once:</p> <pre><code>TEST(StringUtils, ReverseWithSetConfig)\n{\n    auto prop = property([](const std::string&amp; original) {\n        std::string reversed = reverseString(original);\n        std::string reversedTwice = reverseString(reversed);\n        PROP_ASSERT_EQ(original, reversedTwice);\n    });\n\n    // Batch configuration using setConfig()\n    prop.setConfig({\n        .seed = 12345,\n        .numRuns = 500,\n        .maxDurationMs = 5000\n    }).forAll();\n}\n</code></pre> <p>Capability of <code>property()</code>:</p> <p>with a <code>Property</code> object obtained from <code>property()</code> higher order function, you can perform various test combinations with custom configurations, using the same property function.</p> <ul> <li>Can test with random examples: <code>.forAll()</code><ul> <li>Can set number of runs: <code>.setNumRuns(500)</code> - stops after this many runs</li> <li>Can set maximum duration: <code>.setMaxDurationMs(5000)</code> - stops after this many milliseconds (whichever limit is reached first)</li> <li>Can set random seed: <code>.setSeed(12345)</code> for reproducibility</li> <li>Can batch configure: <code>.setConfig({.seed = 123, .numRuns = 500})</code> - configure multiple options at once (C++20)</li> </ul> </li> <li>Can test specific examples: <code>.example(\"hello\")</code></li> <li>Can test all possible combinations: <code>.matrix({\"a\", \"ab\", \"abc\"})</code></li> </ul> <p>Note: When both <code>setNumRuns()</code> and <code>setMaxDurationMs()</code> are set, the test stops when either limit is reached - whichever comes first.</p>"},{"location":"Walkthrough/#alternative-configure-forall-directly-c20","title":"Alternative: Configure <code>forAll()</code> directly (C++20)","text":"<p>Instead of using <code>property().setX().forAll()</code>, you can configure <code>forAll()</code> directly using designated initializers (C++20). This provides a cleaner syntax for simple configuration cases:</p> <pre><code>TEST(StringUtils, ReverseWithForAllConfig)\n{\n    // Configure forAll directly with seed and number of runs\n    forAll([](const std::string&amp; original) {\n        std::string reversed = reverseString(original);\n        std::string reversedTwice = reverseString(reversed);\n        PROP_ASSERT_EQ(original, reversedTwice);\n    }, {\n        .seed = 12345,\n        .numRuns = 500\n    });\n}\n</code></pre> <p>You can also combine configuration with explicit generators:</p> <pre><code>TEST(StringUtils, ReverseWithConfigAndGenerators)\n{\n    forAll([](const std::string&amp; original) {\n        std::string reversed = reverseString(original);\n        PROP_ASSERT_EQ(original.length(), reversed.length());\n    }, {\n        .seed = 0,\n        .numRuns = 100,\n        .maxDurationMs = 5000\n    }, gen::string(gen::character(), 0, 100));\n}\n</code></pre> <p>When to use which:</p> <ul> <li>Use <code>forAll()</code> with configuration <code>{ ... }</code> for simple, one-off configurations</li> <li>Use <code>property().setConfig({ ... }).forAll()</code> or <code>property().setX().setY().forAll()</code> when you need to reuse the property object to chain multiple operations (like <code>.example()</code> or <code>.matrix()</code>)</li> </ul> <p>See Property API Reference for complete details on configuration options and methods.</p>"},{"location":"Walkthrough/#step-6-testing-multiple-properties-together","title":"Step 6: Testing Multiple Properties Together","text":"<p>You can test multiple related properties in one test:</p> <pre><code>TEST(StringUtils, ReverseProperties)\n{\n    // Property 1: Reversing twice is identity\n    forAll([](const std::string&amp; s) {\n        PROP_ASSERT_EQ(s, reverseString(reverseString(s)));\n    });\n\n    // Property 2: Reversed string has same length\n    forAll([](const std::string&amp; s) {\n        PROP_ASSERT_EQ(s.length(), reverseString(s).length());\n    });\n\n    // Property 3: Reversing empty string yields empty string\n    // For specific examples, use property().example() instead\n}\n</code></pre> <p>Or better, use the <code>property().example()</code> for specific cases:</p> <pre><code>TEST(StringUtils, ReverseEdgeCases)\n{\n    auto prop = property([](const std::string&amp; s) {\n        PROP_ASSERT_EQ(s.length(), reverseString(s).length());\n    });\n\n    // Test specific examples\n    prop.example(\"\");\n    prop.example(\"a\");\n    prop.example(\"ab\");\n    prop.example(\"hello world\");\n}\n</code></pre> <p>See Property API Reference for details on <code>.example()</code> and <code>.matrix()</code> methods.</p>"},{"location":"Walkthrough/#step-7-testing-with-multiple-parameters","title":"Step 7: Testing with Multiple Parameters","text":"<p>Properties can have multiple parameters with different types:</p> <pre><code>TEST(Container, VectorOperations)\n{\n    forAll([](const std::vector&lt;int&gt;&amp; vec, int value) {\n        // Property: Adding then removing should preserve size (if value wasn't present)\n        auto vecCopy = vec;\n        auto originalSize = vecCopy.size();\n\n        vecCopy.push_back(value);\n        PROP_ASSERT_EQ(vecCopy.size(), originalSize + 1);\n\n        // Remove the value we just added\n        vecCopy.pop_back();\n        PROP_ASSERT_EQ(vecCopy.size(), originalSize);\n    });\n}\n</code></pre> <p>Note: Each parameter type needs a generator. Built-in types like <code>int</code>, <code>std::string</code>, <code>std::vector&lt;T&gt;</code> have default generators, so you don't need to specify them unless you want custom ranges. Notice we use <code>const std::vector&lt;int&gt;&amp;</code> (const reference) for the vector and <code>int</code> (value) for the integer - both value types and const reference types work identically (see Step 4.5 for details).</p>"},{"location":"Walkthrough/#step-8-using-statistics-to-understand-test-coverage","title":"Step 8: Using Statistics to Understand Test Coverage","text":"<p>You can collect statistics about the generated inputs:</p> <pre><code>TEST(Statistics, CollectingStats)\n{\n    forAll([](int value) {\n        PROP_STAT(value &gt; 0);  // Track how often value &gt; 0\n        PROP_STAT(value &lt; 0);  // Track how often value &lt; 0\n        PROP_STAT(value == 0);  // Track how often value == 0\n\n        // Your actual property test\n        PROP_ASSERT_GE(value * value, 0);  // Square is always non-negative\n    });\n}\n</code></pre> <p><code>PROP_STAT(condition)</code>:</p> <ul> <li>Tracks how often the condition is true or false</li> <li>Doesn't fail the test if false</li> <li>Useful for understanding input distribution</li> <li>Statistics are printed at the end of the test run</li> <li>The key is automatically derived from the condition expression by the precompiler</li> </ul> <p><code>PROP_TAG(KEY, VALUE)</code>:</p> <ul> <li>Similar to <code>PROP_STAT</code>, but allows you to specify a custom key name</li> <li>Tracks how often the VALUE is true or false with your custom KEY</li> <li>Useful when you want more descriptive or grouped statistics</li> <li>Doesn't fail the test if VALUE is false</li> <li>Statistics are printed at the end of the test run</li> </ul> <p><code>PROP_CLASSIFY(condition, KEY, VALUE)</code>:</p> <ul> <li>Conditionally tags test cases only when the condition is true</li> <li>Only applies the tag when the condition evaluates to true (unlike <code>PROP_TAG</code> which tracks both true and false)</li> <li>Useful for categorizing test cases into groups based on conditions</li> <li>Doesn't fail the test if condition is false</li> <li>Statistics are printed at the end of the test run</li> </ul> <pre><code>TEST(Statistics, UsingTags)\n{\n    forAll([](int value) {\n        PROP_STAT(value &gt; 0);  // Key: \"value &gt; 0\"\n        PROP_TAG(\"positive\", value &gt; 0);  // Key: \"positive\" (custom)\n        PROP_TAG(\"in range\", value &gt;= 0 &amp;&amp; value &lt; 100);  // Key: \"in range\" (custom)\n\n        PROP_ASSERT_GE(value * value, 0);\n    });\n}\n\nTEST(Statistics, UsingClassify)\n{\n    forAll([](int x, int y) {\n        // Only tag when conditions are true\n        PROP_CLASSIFY(x == y, \"relationship\", \"equal\");\n        PROP_CLASSIFY(x &gt; y, \"relationship\", \"greater\");\n        PROP_CLASSIFY(x &lt; y, \"relationship\", \"less\");\n        PROP_CLASSIFY(x % 2 == 0, \"parity\", \"even\");\n        PROP_CLASSIFY(y % 2 == 0, \"parity\", \"even\");\n\n        PROP_ASSERT_EQ(x + y, y + x);\n    });\n}\n</code></pre> <p>See Test Strategies for more advanced testing techniques and statistics usage.</p>"},{"location":"Walkthrough/#step-9-integrating-with-google-test-macros","title":"Step 9: Integrating with Google Test Macros","text":"<p>To make property test failures properly reported as failures in your Google Test, use the provided macros:</p> <pre><code>TEST(StringUtils, ReverseWithGTestIntegration)\n{\n    // This will properly fail the Google Test if property fails\n    EXPECT_FOR_ALL([](const std::string&amp; s) {\n        PROP_ASSERT_EQ(s, reverseString(reverseString(s)));\n    });\n\n    // Or use ASSERT_FOR_ALL for fatal failures\n    ASSERT_FOR_ALL([](const std::string&amp; s) {\n        PROP_ASSERT_EQ(s.length(), reverseString(s).length());\n    });\n\n    // For Cartesian product tests, use EXPECT_MATRIX or ASSERT_MATRIX\n    EXPECT_MATRIX([](const std::string&amp; a, const std::string&amp; b) {\n        PROP_ASSERT_EQ(a.length() + b.length(), (a + b).length());\n    }, {\"\", \"a\", \"ab\"}, {\"\", \"x\", \"xy\"});\n}\n</code></pre> <p>Difference:</p> <ul> <li><code>forAll()</code> and <code>matrix()</code> return <code>bool</code> - you need to wrap them: <code>EXPECT_TRUE(forAll(...))</code> or <code>EXPECT_TRUE(matrix(...))</code></li> <li><code>EXPECT_FOR_ALL(...)</code> - Shorthand for <code>EXPECT_TRUE(forAll(...))</code></li> <li><code>ASSERT_FOR_ALL(...)</code> - Shorthand for <code>ASSERT_TRUE(forAll(...))</code></li> <li><code>EXPECT_MATRIX(callable, ...lists)</code> - Shorthand for <code>EXPECT_TRUE(matrix(callable, ...lists))</code> (Cartesian product)</li> <li><code>ASSERT_MATRIX(callable, ...lists)</code> - Shorthand for <code>ASSERT_TRUE(matrix(callable, ...lists))</code> (Cartesian product)</li> </ul> <p>See Property API Reference - Google Test Integration Macros for more details.</p>"},{"location":"Walkthrough/#step-10-handling-failures-and-shrinking","title":"Step 10: Handling Failures and Shrinking","text":"<p>When a property fails, <code>cppproptest</code> automatically tries to shrink the counterexample to a simpler one:</p> <pre><code>TEST(Example, FailingProperty)\n{\n    forAll([](const std::vector&lt;int&gt;&amp; vec) {\n        // This will fail for non-empty vectors\n        PROP_ASSERT_EQ(vec.size(), 0);\n    });\n}\n</code></pre> <p>What happens on failure:</p> <ol> <li>Test finds a counterexample (e.g., <code>vec = [42, 17, 99]</code>)</li> <li>Shrinking process tries to simplify it</li> <li>May find a simpler counterexample (e.g., <code>vec = [0]</code> or <code>vec = [1]</code>)</li> <li>Reports the minimal counterexample</li> </ol> <p>See Shrinking for a detailed explanation of how shrinking works and how to customize it.</p> <p>Reproducing failures: When a test fails, <code>cppproptest</code> reports a seed. You can reproduce it:</p> <pre><code>// Using property() API\nauto prop = property([](const std::vector&lt;int&gt;&amp; vec) {\n    PROP_ASSERT_EQ(vec.size(), 0);\n});\n\nprop.setSeed(12345678).forAll();  // Use the seed from failure\n\n// Or using forAll() with configuration (C++20)\nforAll([](const std::vector&lt;int&gt;&amp; vec) {\n    PROP_ASSERT_EQ(vec.size(), 0);\n}, {\n    .seed = 12345678\n});\n</code></pre> <p>Or set it via environment variable: <pre><code>PROPTEST_SEED=12345678 ./your_test\n</code></pre></p>"},{"location":"Walkthrough/#step-11-testing-complex-data-structures","title":"Step 11: Testing Complex Data Structures","text":"<p>You can test properties involving complex data structures:</p> <pre><code>TEST(DataStructures, MapProperties)\n{\n    forAll([](const std::map&lt;int, std::string&gt;&amp; m, int key, const std::string&amp; value) {\n        auto mCopy = m;\n        mCopy[key] = value;\n\n        // Property: After insertion, map should contain the key\n        PROP_ASSERT_NE(mCopy.find(key), mCopy.end());\n        PROP_ASSERT_EQ(mCopy[key], value);\n    });\n}\n</code></pre> <p>Some built-in generators for containers:</p> <ul> <li><code>gen::vector&lt;T&gt;()</code> - Vectors</li> <li><code>gen::map&lt;K, V&gt;()</code> - Maps</li> <li><code>gen::set&lt;T&gt;()</code> - Sets</li> <li><code>gen::pair&lt;A, B&gt;()</code> - Pairs</li> <li><code>gen::tuple&lt;...&gt;()</code> - Tuples</li> </ul> <p>See Generators - Container Generators for complete details and configuration options.</p>"},{"location":"Walkthrough/#step-12-creating-custom-generators","title":"Step 12: Creating Custom Generators","text":"<p>For custom types, you may want to create custom generators for multiple uses:</p> <pre><code>struct Point {\n    int x, y;\n};\n\n// Define a generator for Point using combinators\nauto pointGen = gen::tuple(gen::interval(-100, 100), gen::interval(-100, 100))\n    .map&lt;Point&gt;([](const std::tuple&lt;int, int&gt;&amp; t) {\n        return Point{std::get&lt;0&gt;(t), std::get&lt;1&gt;(t)};\n    });\n\nTEST(Geometry, PointProperties)\n{\n    forAll([](const Point&amp; p) {\n        // Property: Distance from origin is non-negative\n        double dist = std::sqrt(p.x * p.x + p.y * p.y);\n        PROP_ASSERT_GE(dist, 0.0);\n    }, pointGen);\n}\n</code></pre> <p>See Custom Generator for detailed instructions on creating custom generators, and Combinators for using generator combinators like <code>map</code>, <code>filter</code>, and <code>flatMap</code>.</p> <p>See Arbitraries for more on arbitraries(default generators) and how to make a new arbitrary out of a custom generator.</p>"},{"location":"Walkthrough/#common-patterns-and-best-practices","title":"Common Patterns and Best Practices","text":"<p>For more testing strategies and patterns, see Test Strategies.</p>"},{"location":"Walkthrough/#pattern-1-round-trip-properties","title":"Pattern 1: Round-trip Properties","text":"<p>Test that encoding/decoding, serialization/deserialization, etc. preserve data:</p> <pre><code>TEST(Codec, EncodeDecodeRoundTrip)\n{\n    forAll([](const MyData&amp; data) {\n        auto encoded = encode(data);\n        auto decoded = decode(encoded);\n        PROP_ASSERT_EQ(data, decoded);\n    });\n}\n</code></pre>"},{"location":"Walkthrough/#pattern-2-invariant-properties","title":"Pattern 2: Invariant Properties","text":"<p>Test that operations preserve invariants:</p> <pre><code>TEST(Container, SizeInvariant)\n{\n    forAll([](std::vector&lt;int&gt;&amp; vec, int value) {\n        size_t originalSize = vec.size();\n        vec.push_back(value);\n        PROP_ASSERT_EQ(vec.size(), originalSize + 1);\n    });\n}\n</code></pre>"},{"location":"Walkthrough/#pattern-3-idempotency","title":"Pattern 3: Idempotency","text":"<p>Test that applying an operation twice is the same as once:</p> <pre><code>TEST(Operations, Idempotent)\n{\n    forAll([](MyObject&amp; obj) {\n        auto original = obj;\n        normalize(obj);\n        normalize(obj);  // Apply twice\n        PROP_ASSERT_EQ(obj, original);  // Should be same as after first normalize\n    });\n}\n</code></pre>"},{"location":"Walkthrough/#pattern-4-commutativity-and-associativity","title":"Pattern 4: Commutativity and Associativity","text":"<p>Test mathematical properties:</p> <pre><code>TEST(Math, AdditionProperties)\n{\n    // Commutativity\n    forAll([](int a, int b) {\n        PROP_ASSERT_EQ(a + b, b + a);\n    });\n\n    // Associativity\n    forAll([](int a, int b, int c) {\n        PROP_ASSERT_EQ((a + b) + c, a + (b + c));\n    });\n}\n</code></pre>"},{"location":"Walkthrough/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Walkthrough/#problem-compile-error-about-missing-generator","title":"Problem: Compile error about missing generator","text":"<p>Solution: Specify a generator explicitly or create a custom one: <pre><code>forAll([](MyCustomType t) { ... }, myCustomTypeGenerator);\n</code></pre> See Custom Generator for creating generators for custom types.</p>"},{"location":"Walkthrough/#problem-test-runs-too-slowly","title":"Problem: Test runs too slowly","text":"<p>Solution: Reduce number of runs, set a maximum duration, or limit input size: <pre><code>property([](...) { ... })\n    .setNumRuns(100)  // Reduce from default 1000\n    .forAll();\n\n// Or limit by time instead of number of runs\nproperty([](...) { ... })\n    .setMaxDurationMs(5000)  // Stop after 5 seconds\n    .forAll();\n\n// Or use both - stops when either limit is reached\nproperty([](...) { ... })\n    .setNumRuns(1000)\n    .setMaxDurationMs(10000)  // Stop after 10 seconds or 1000 runs, whichever comes first\n    .forAll();\n</code></pre></p>"},{"location":"Walkthrough/#problem-need-to-test-specific-values","title":"Problem: Need to test specific values","text":"<p>Solution: Use <code>.example()</code> or <code>.matrix()</code>: <pre><code>auto prop = property([](int x) { ... });\nprop.example(0);\nprop.example(INT_MAX);\nprop.matrix({-1, 0, 1});\n</code></pre></p>"},{"location":"Walkthrough/#problem-property-fails-but-counterexample-is-too-complex","title":"Problem: Property fails but counterexample is too complex","text":"<p>Solution: Shrinking should help automatically, but you can also constrain generators: <pre><code>forAll([](int x) { ... }, gen::interval(-10, 10));  // Smaller range\n</code></pre> See Shrinking for details on how shrinking works and how to customize it.</p>"},{"location":"Walkthrough/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore:</p> <ul> <li>Generators - Learn about all available generators</li> <li>Combinators - Combine generators to create new ones</li> <li>Shrinking - Understand how counterexamples are simplified</li> <li>Stateful Testing - Test state machines and sequences</li> <li>Property API Reference - Complete API documentation</li> </ul>"},{"location":"Walkthrough/#summary","title":"Summary","text":"<p>Creating a property test involves:</p> <ol> <li>Define the property - Write a function/lambda that expresses what should always be true</li> <li>Choose generators - Specify how to generate inputs (or use defaults)</li> <li>Run the test - Use <code>forAll()</code> or <code>property().forAll()</code></li> <li>Handle failures - Use reported seeds to reproduce and fix issues</li> </ol> <p>The key insight: Instead of testing specific examples, you're testing universal properties that should hold for all (or most) inputs in a domain.</p>"},{"location":"WhyPropertyBasedTesting/","title":"Why Property-based testing?","text":""},{"location":"WhyPropertyBasedTesting/#generalization-and-abstraction","title":"Generalization and abstraction","text":"Example-Based Testing Property-Based Testing Hardcoded examples Abstract specifications Narrow test scope Near-complete input domain Behavior implied Behavior expressed <p>Property-based testing, or PBT in short, lets you write a test using abstract idea, instead of some dummy examples or contrived scenarios that are easy to break over time and hard to interpret. You can write tests using specification or requirements - which are essentially expressed as combination of input domain and expected behavior (=properties) of tested component.</p>"},{"location":"WhyPropertyBasedTesting/#clear-separation-of-variants-and-invariants","title":"Clear separation of variants and invariants","text":"Example-Based Testing Property-Based Testing Mixed input &amp; checks Separate domain &amp; property Fragile to input changes Stable under variation Buried intent Clear intent <p>Describing a test using input domain and expected behavior means that we have clear cut between variants and invariants. We often mix variants and invariants in our tests in typical example-based tests. This is one of the reasons why those tests become hard to maintain and difficult to read over time. In property-based tests, however, we clearly separate invariants as properties and variants as input domain. Thus tests become more readable and gets easier to maintain, as they carry test writers' intention better.</p>"},{"location":"WhyPropertyBasedTesting/#convenience-and-versatility","title":"Convenience and versatility","text":"Example-Based Testing Property-Based Testing Manual input crafting Auto-generated inputs Hard-coded constraints Declarative building blocks Edge cases missed Edge cases discovered <p>Property-based testing often provides with the convenient out-of-box generators (sometimes called strategies) and combinators (that lets you make new generators out of existing ones), and lets you to effortlessly define the input domain for your tests. You can specify your input domains using various notions - range, constraint, union, transformation, composition, and dependency, just to name a few.</p>"},{"location":"WhyPropertyBasedTesting/#reusability-and-scalability","title":"Reusability and Scalability","text":"Example-Based Testing Property-Based Testing Hard to reuse Reusable properties/domains One-off logic Modular building blocks Low scalability Scales naturally <p>As it defines input domain with generators and combinators, Property-based testing lets you define and reuse existing input domain and properties to build new input domain and properties with ease. These new ones then can be reused as building blocks for next tests and so on. Reusable nature of property-based testing lets you write tests with scale. Complex combinations of components can be readily tested if simpler pieces are already available by tests written previously.</p> <p> </p>"},{"location":"WhyPropertyBasedTesting2/","title":"WhyPropertyBasedTesting2","text":""},{"location":"WhyPropertyBasedTesting2/#an-attempt-to-approximate-software-quality","title":"An attempt to approximate software quality","text":"<p>Property-based testing, or sometimes refered to as specification-based testing, tries to verify software's integrity by validating the requirements of a software component, where the requirements are often written as properties(or specifications). They are validated using massive input combinations.</p> <pre><code>    // encode &amp; decode are inverse functions\n    ASSERT(decode(encode(text)) == text);\n</code></pre> <p>Many property-based testing implementations derive their ideas from QuickCheck, which was originally written in Haskell. Quickcheck's basic idea is to quickly prove a theorem, as the name suggests. But how can anything possibly be proved about software? A software piece is often too complex to reason about in definitive way. If we randomly choose 100 input combinations to test your component and confirm that it satisfies the required properties with every 100 of the combinations, you may argue that it's still not proving anything. But how about if we increase the number of combinations to 1,000, or 10,000?</p> <p>Certainly there still remains some possibility that one of the untested input combinations might fail the properties. But we can say this as an approximation - an approximation of software integrity or quality. As the number of evidences grows, more accurate the approximation it becomes. It's often very effective to approximate an answer when it cannot be easily obtained. It's sometimes the only feasible way.</p> <p>Property-based testing can do exactly that. You define a property (or 'specification') of a software component should satisfy, then you can let the test library prove or disprove that requirement automatically by feeding in random (but valid) input combinations.</p> <p>In fact, often the underlying issues of a component are easily detected than you can imagine. Some properties may hold true with a few combinations, but such luck usually cannot last for long. The issues reveal themselves eventually.</p> <p>In property-based testing, software requirements can be validated in automated fashion as in static code analyses, but by actually running the code as in dynamic code analyses. By actually running the code, we can check for many software requirements and issues that are usually not feasible to find with static code analyses.</p> <p> </p>"},{"location":"WhyPropertyBasedTesting2/#why-property-based-testing-for-c","title":"Why property-based testing for C++?","text":"<p>Property-based tesing relies on massive input combinations to be attempted to achieve high confidence. For example, if you have a function with 10 boolean flags to be thoroughly tested in runtime, you need to test it with <code>2</code><sup><code>10</code></sup> <code>= 1024</code> combinations. This kind of complexity has been often considered as unmanageable and something that should be avoided. However, as most C++ unit components (as single unit or multiple components combined) tend to execute blazingly fast on modern machines, running them 1000 times is usually not an issue. Unless it's involving external devices like secondary disk or network communication, running a typical C++ component 1000 times would normally end up finishing under a second barrier. This is why C++ and property-based testing is a fine pair.</p> <p>I feel many of the existing property-based testing implementation in C++ are either outdated or too daunting to learn due to their complexity. <code>cppproptest</code> focuses on lowering the learning curve while maintaining feature-completeness.</p>"}]}